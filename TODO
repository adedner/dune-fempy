aS) (Andreas) explain JIT compilation approach and require compilation time in Section 6
bS) (Robert) Other packages (Fenics compatibility) - mention differences, e.g.,
    use of TrialFunction instead of Function for ufl model - possibly change
    "solve" so that TrialFunction is not rquired,
    solution could be to add a parameter \pyth{solution=u}
    during model/scheme/operator generation and then use
    \pyth{replace(form,dict(u=TrialFunction)}}
cS) (RA) Show DBCs in 'Alternative Backends' or in a section before that
CI) (RA) how to define the boundary?
     i) can we read boundary ids from gmesh?
    ii) dgf file
   iii) use a hpdg space (if load balancing works?) (Robert)
    iv) pass callbacks to model (Andreas)
dS) (Robert) solver parameter
eI) (Robert) dof manager: set no entries to zero
fI) (Andreas) plot of error/dofs in laplace-adaptive.py
gS) (Andreas) move C++ Forchheimer from Section 7 to Section 6 without too much detail on the model generation
hI) (Andreas) NamedConstant -> Constant (Andreas)
eI) (Andreas) docker container

(RA) Add to Introduction:
follow the Fem interface,
keep flexibility of adding C++ code also to extend models and due rapid
prototyping - generate simple code which is easy to use in other C++
algorithms
