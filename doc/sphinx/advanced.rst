.. role:: red

.. raw:: html

    <style> .red {color:red} </style>

.. raw:: html

  <h1> Advanced topics </h1>

.. contents::
   :local:
   :depth: 2
   :backlinks: top


.. _advancedintro:

****************************************************************
Exporting Different Implementations of an Interface Class
****************************************************************

.. _database:

Database approach
===================

To provide the information required to export an implementation of the
wrapper class, we use a python dictonary containing information to generate the
typedef for the implementation and the required include statements needed
to compile the wrapper. Given the above, an example for generating a grid
containing the required dictonaries would be the following:

.. code-block:: python

  "ALUCubeGrid" :
  {
    "type"      : "Dune::ALUGrid< $(dimgrid), $(dimworld), Dune::cube, Dune::nonconforming >",
    "default"   : [ "dimworld=$(dimgrid)" ],
    "checks"    : [ "$(dimgrid)==$(dimworld) or $(dimgrid)+1==$(dimworld)",
                    "2<=$(dimworld) and $(dimworld)<=3",
                    "2<=$(dimgrid) and $(dimgrid)<=3" ],
    "include"   : [ "dune/alugrid/grid.hh", "dune/alugrid/dgf.hh" ]
  }

This would be located in the directory *python/database/grid*. The first line provides
information on how to construct the correct typedef for the Dune class:

.. code-block:: c++

  template< int dimgrid, int dimworld,  ALU3dGridElementType elType>
  class ALU3dGrid<dimgrid,dimworld,Dune::cube,Dune::nonconforming>;

The last line contains information about which include statements are
required to compile the wrapper, i.e.

.. code-block:: c++

   #include <dune/alugrid/grid.hh>
   #include <dune/alugrid/dgf.hh>

The remaining two lines provide default values and tests for free
parameters *dimgrid* and *dimworld*.

On the fly code generation is done with the python module *dune.generator*.

.. autoclass:: dune.generator.generator.Generator
   :members:
   :special-members: __init__

In the above example the extension module for our grid implementation would
be generated by calling

.. code-block:: python

     aluModule = dune.fem.grid.get("ALUCubeGrid", dimgrid=2, dimworld=3)

The header file is generated in this example:

.. code-block:: c++

  #include <dune/fempy/py/grid.hh>

  #include <dune/alugrid/grid.hh>
  #include <dune/alugrid/dgf.hh>
  #include <dune/fem/gridpart/adaptiveleafgridpart.hh>

  typedef Dune::Fem::AdaptiveLeafGridPart<Dune::ALUGrid< 2, 3, Dune::cube, Dune::nonconforming >> DuneType;

  PYBIND11_PLUGIN( grid_b0c984fadf189dd71b778f1255c71abb )
  {
    pybind11::module module( "grid_b0c984fadf189dd71b778f1255c71abb" );
    Dune::FemPy::registerGrid< DuneType >( module );
    return module.ptr();
  }

Let us examine what this code does. The second and third includes come from the database entry for ALUCubeGrid
as seen above. The first and fourth includes are a default for whenever generator is passed a grid. In particular
`dune/fempy/py/grid.hh` contains the function `registerGrid`. When this function is called, it creates a python module
using the `DuneType` typedef. Specifically, what it does is create a class using the GridPart, which it exports to
python using PyBind11.

.. code-block:: c++

  auto grid = registerGridPart< GridPart >( module, "LeafGrid" );

The actual library for the extension module will be generated in *python.dune.generated* within the
cmake build directory tree. The name of the library is taken by hashing the
Dune type of the implementation class.

Summary
------------

The :py:class:`.generator.Generator` class is used to perform on the fly
generation and import of extension modules for one given realization of a C++ interface class *InterfaceClass*.
The details of each realization is provided through dictonaries contained
in files within the directory *python/database/interfaceName* where
*interfaceName* is the identifier used for the *InterfaceClass*. The
dictionary contains the means for constructing the correct type (*DuneType*
in the following) and a list of required include files. Calling the method
:py:meth:`.Generator.getModule`
with the identifier used in
the dictionary for the desired implementation and the name parameters
required to fix *DuneType* results in a single header
*python/dune/generated/generated_module.hh*. This file includes all headers
provided in the dictionary plus a header *pyinterfaceName.hh* containing the
definition of the wrapper code and the PyBind11 python export. The extension library is built
using the *cmake* build system with the *generate_module* target. The resulting library
is renamed and imported into the python environment.

.. note::
  The extension module will only be built if it does not exist
  already, i.e. no additional checks are performed to determine if
  the dependencies for this module have changed.

`Scheme wrapper class`_
----------------------------------------------
.. _Scheme wrapper class: file:../../doxygen/html/struct_scheme.html
