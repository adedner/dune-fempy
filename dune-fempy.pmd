\documentclass{ansarticle}

\definecolor{hrefcolor}{rgb}{0.0,0.0,0.8}
\newcommand{\linkcolor}{hrefcolor}
\hypersetup{pdfstartview=FitR}
\hypersetup{pdftitle={The DUNE-Fempy Module},
            pdfauthor={L. Connellan, A. Dedner, M. Nolte},
            breaklinks=true,
            linkbordercolor=\linkcolor,
            urlbordercolor=\linkcolor,
            citebordercolor=\linkcolor,
            runbordercolor=\linkcolor,
            menubordercolor=\linkcolor,
            filebordercolor=\linkcolor,
            runcolor=\linkcolor
            baseurl={https://gitlab.dune-project.org/extensions/dune-alugrid}
}
% make links underlined in acrobat reader
\hypersetup{pdfborderstyle={/S/U/W 1}}
\newcommand*\diff{\mathop{}\!\mathrm{d}}

%<*pre>
\usepackage{anslistings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{a4wide}
\usepackage{comment}
\usepackage{minted}
\usepackage{subcaption}

\newcommand{\dune}[1][]{\textsc{Dune}\ifx&#1&\else\textsc{-{#1}}\fi\xspace}
\newcommand{\alugrid}{\textsc{ALUGrid}\xspace}
\newcommand{\ug}{\textsc{UG}\xspace}
\newcommand{\sionlib}{\textsc{SIONlib}\xspace}
\newcommand{\alberta}{\textsc{ALBERTA}\xspace}
\newcommand{\yaspgrid}{\textsc{YaspGrid}\xspace}

\newcommand{\matplotlib}{\pyth{Matplotlib}\xspace}
\newcommand{\quadpy}{\pyth{Quadpy}\xspace}
\newcommand{\numpy}{\pyth{Numpy}\xspace}
\newcommand{\scipy}{\pyth{Scipy}\xspace}
\newcommand{\paraview}{Paraview\xspace}
\newcommand{\vtk}{VTK\xspace}
\newcommand{\cmake}{cmake\xspace}
\newcommand{\pybind}{Pybind11\xspace}
\newcommand{\code}[1]{\lstinline[basicstyle=\small\sffamily]{#1} }
\newcommand{\file}[1]{\code{#1}}

\newcommand{\Atodo}[1]{\todo[inline]{{\bf\color{green}Andreas:} #1}}
\newcommand{\Ltodo}[1]{\todo[inline]{{\bf\color{blue}Lloyd:} #1}}
\newcommand{\Mtodo}[1]{\todo[inline]{{\bf\color{green}Martin:} #1}}

\newcommand{\autocite}{\cite}
\newcommand{\pweavecaption}{}
\newcommand{\pweavelabel}{}
\lstnewenvironment{pweavecode}[1][]{\lstset{escapechar=`,moredelim=[il][]{\#tex},style=pythonstyle, title={\codetitlestyle{Python code }},belowcaptionskip=\belowtitleskip, caption=\pweavecaption,label=\pweavelabel}}{}
\lstnewenvironment{pweaveout}[1][]{\lstset{style=gencodestyle, title={\codetitlestyle{Output}}, belowcaptionskip=\belowtitleskip}}{}
%</pre>

\begin{document}

\title{The \dune[Fempy] Module}
\author[1]{Lloyd Connellan}% \thanks{l.connellan@warwick.ac.uk}}
\author[2]{Andreas Dedner}% \thanks{a.s.dedner@warwick.ac.uk}}
\author[3]{Martin Nolte}%\thanks{nolte@mathematik.uni-freiburg.de}}
\affil[1]{University of Warwick, UK}
\affil[2]{University of Warwick, UK}
\affil[3]{University of Freiburg, Germany}
\runningtitle{The \dune[Fempy] Module}
\runningauthor{Connellan, Dedner, Nolte}

\providecommand{\keywords}[1]{\textbf{Keywords: } #1}

\date{November, 2017}

\maketitle

Remove the following from the final tex output - leave in now so that
ptangle works
```python, label = "intro"
import time
import numpy
import math
import dune.plotting
dune.plotting.block = False
```

\begin{abstract}
In this paper we present the new \dune[Fempy] module...

\noindent
\keywords{..., \dune}
\end{abstract}

\section{Introduction}

Bullet point list of things to mention here:

\begin{enumerate}
  \item Remark on the importance of FEMs and their varied uses.
  \item Existing FEM software packages, both c++ libraries and the
  trend towards python packages and where there is a niche for fempy.
  \item Corepy/Python and overview of the features it has introduced,
  such as creation of .cache for efficiency of repeat usage.
  \item Usage of more recent pybind11 and C++11 features compared to
  other packages.
\end{enumerate}

\Atodo{depending on the journal we would need to describe a bit about the
technical side:
(1) generator (2) create mechanism since it is heavily used here.
The first could be a more technical description taken from the python paper
the later would be new. If we want to try TOMS then perhaps having the 
HTTP generator?}
\Atodo{do we want to add something on parallelism}
\Atodo{which other features are missing? Should we include an example on
non variational problems or bounding box dg?}
\Atodo{the mc flow example makes use of the low level bindings for the dune
grid for postporcessing - perhaps we should have that feature as an extra
section?}

%<*tag>

\section{Finite Element Methods in Fempy} \label{sec:fem-in-fempy}

When designing any software package, a natural challenge that arises
is trying to make the user interface as simple and easy to use as possible.
At the same time however, we also want to create an interface that retains
all the functionality we need.

In the context of finite element methods (FEMs), this leads to the question
of what the minimal functional structure for a FEM looks like. In
order to try to address this question, we will first outline from a
mathematical standpoint the general structure we have in mind for a
FEM.

To begin with, the original problem we typically want to apply a finite
element method to is a continuous PDE in some
infinite-dimensional space $V$. First let $\Omega \subset \mathbb{R}^d$ be
a polygonal domain for our problem. We then choose a (conforming)
finite element space $V_h = \{ v_h : \Omega \to \mathbb{R}^r \}
\subset V$, where dim $V_h = N$. This involves choosing a basis for
$V_h$, which can vary depending on the problem, but typically involves
piecewise polynomial functions.

Next the variational (or weak) form of the equation is defined. For
the purpose of illustration, let us assume to start with we have a
parabolic PDE of the following general form.

\begin{equation*}
  \begin{array}{ll}
  \partial_t u + L[u] = f & \mbox{in } \Omega \times [0, T], \\
  u(x, 0) = u^0(x) & \mbox{in } \Omega, \\
  D \cdot \textbf{n} = \phi(x) & \mbox{on } \Gamma \times [0, T],
  \end{array}
\label{eqn:parabolic}
\end{equation*}

where the elliptic operator L is defined as

\begin{equation*}
  L[u] := -\nabla \cdot D(x, u, \nabla u) \nabla u(x) + m(x, u, \nabla u).
\label{eqn:elliptic}
\end{equation*}

and $u^0$ and $\phi$ are the initial and boundary conditions. The
variational form is then obtained in the usual way via integration by
parts and discretization in time. This leads to methods that take the following form.

\begin{equation}
  \int_{\Omega} u^{n+1} + \Delta t L_I[u^{n+1}] \diff x = \int_{\Omega} u^n + \Delta t L_E[u^n] \diff x.
\label{eqn:rothe}
\end{equation}

where $L_I$ and $L_E$ are the implicit and explicit parts of $L$,
defined as
\Atodo{should we make the forcing and boundary flux also partially implicit?}
\Atodo{mention that this is a simple scheme and other higher order schemes
can be easily implemented along the same lines?}
\Atodo{giving $\theta$ scheme as example?}
\begin{gather}
  L_I[u] = D_1(x, u \nabla u) \cdot \nabla \varphi + m_1(x, u, \nabla u) \varphi, \quad \\
  L_E[u] = D_2(x, u \nabla u) \cdot \nabla \varphi + (m_2(x, u, \nabla u) + f^n + \phi^n) \varphi,
\label{eqn:im-ex}
\end{gather}

and $D_1 -D_2 = D$, $m_1 - m_2 = m$. The last step is to
solve this system iteratively for $u^{n+1} \in V_h$. This also
involves potential variation in terms of the solver used and possible
nonlinearity of the problem.

%In the case where $D(u(x), x)$ and $m(u(x), x)$ are nonlinear,
%Newton's method is used to solve the system. Denoting the general PDE
%by the operator $L(u)$, that gives us the iteration

%\begin{equation}
%  L(u^n) = -DL(u^n, \delta^n)(u^{n+1} - u^n),
%\label{eqn:newton}
%\end{equation}

%where $DL$ is the Jacobian of $L$.

With this general form in mind, in \dune[Fempy] we have designed the
structure to take as similar a style as possible, which results in the
following breakdown of parts.

\begin{itemize}
  \item \ref{sec:grids} Grids. The computational domain the problem is set in.
  \item \ref{sec:functions} Functions. Functions defined on the grid that store the
  solution and other variables.
  \item \ref{sec:spaces} Spaces. The finite element space and type of basis functions.
  \item \ref{sec:schemes} Schemes. The weak form of the equation, its
  boundary conditions, and method for solving.
  \item \ref{sec:solving} Solving. The actual solving process and data
  output.
\end{itemize}

We note that there exist even further simplifications that can be made
in terms of this design choice; for instance a FEM could be
distilled to simply choosing a bilinear form (an operator) and a grid,
and having all other things set to sensible defaults. Additionally the code
itself used to represent these methods could be simplified to a large
degree depending on the aim of the software.

Ultimately as a FEM package aimed more at extensibility and for
researchers who are willing to commit to some degree of
programming, we have opted for more complexity in some cases at the
expense of this simplicity. In general this is quite a nuanced design
decision that must be made without a clear \textit{right} answer.

With that in mind, for the remainder of this section we shall
demonstrate in more detail how each of these concepts are implemented
in the context of a worked example, the FEM applied to
the Forchheimer equation \cite{Kieu}.

\subsection{Grids} \label{sec:grids}

The first aspect of FEMs that we consider is probably the most
fundamental aspect, that of the grid (or mesh). Naturally, before looking at the
equations we want to solve themselves, we must look at the
computational domain and how we want to discretize it. Ideally
numerical software looking to emulate FEMs should be able to construct both simple
triangulated 2D domains and more complex surfaces and meshes.

For now we will look at a simple example. Let us suppose we
have a domain of the following form.
\begin{equation*}
  \Omega = \{ (x,y) \in \mathbb{R}^2 : 0 \leq x \leq 1, 0 \leq y \leq 1\}.
\label{eqn:domain}
\end{equation*}

In creating a computational grid for this domain, it will be necessary to specify
the following things.

\begin{enumerate}
  \item The shape (a square) and its vertices.
  \item The number of elements.
  \item The type of elements (squares? triangles?).
\end{enumerate}

With these points in mind, we implement the grid in the following way
in \dune[Fempy] and plot the result.

```python, label="grid", fig=True, caption="Plot of a 2D grid for two different levels of refinement", width="0.475\\textwidth"
from dune.fem.plotting import plotPointData as plot
import dune.create as create
grid = create.grid('ALUConform', dune.grid.cartesianDomain([0, 0], [1, 1], [4, 4]))
plot(grid)
grid2 = create.grid('ALUCube', dune.grid.cartesianDomain([0, 0], [1, 1], [8, 8]))
plot(grid2)
```

We note that the above grid creation code snippet comes with two
arguments. The first which we will see throughout this
example is a keyword for the \dune class we wish to use. In this case
\pyth{ALUConform} corresponds to a triangular discretization, whilst
\pyth{ALUCube} corresponds to squares. These \dune classes can come
from anywhere within a \dune installation and so are intended for
flexible use.

The second argument is an object describing a rectangular
domain by specifying two opposite corners $(0,0)$ and $(1,1)$, and the number
of elements in each direction $(4,4)$ or $(8,8)$. Grids in fempy can
additionally be constructed via gmsh files or \textit{dune grid format} (dgf)
files when more complexity is required.

We note here once more that from a design standpoint, assumptions
could potentially be made to cut down on the complexity needed.
For instance in situations where the exact details are
not necessary, a basic square grid could simply be made with
\pyth{grid = square()}. However such a design comes at the cost of it
being unclear how to make small modifications.
\Atodo{mention \pyth{unitcube}}
\Atodo{do we want forward references to the more complex cases, e.g.,
unstructured mesches}
\Atodo{somewhere we should have a list of available grids and their
features? Of course then a similar list should be available for spaces etc.}

\subsection{Spaces} \label{sec:spaces}

The next key part of a FEM after constructing the grid is defining the
kind of elements we want to use, and by extension their space. In
particular this is important because the order of elements used can
dictate the solvability and the efficiency of the method.

Let us consider a simple case of Lagrange elements. Since we have a 2D
domain with a triangular mesh, we consider shape functions that are 1 on
each separate node (shown in \ref{fig:lagrange-elements}), and 0 on
the others. For orders 2 and 3, the shape functions would be quadratic
and cubic polynomials respectively.

\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.4\linewidth]{figures/lagrange-ele2.jpg}
  \caption{Second order element}
  \label{fig:lagrange2}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.4\linewidth]{figures/lagrange-ele3.png}
  \caption{Third order element}
  \label{fig:lagrange3}
\end{subfigure}
\caption{Node maps of two Lagrange reference elements}
\label{fig:lagrange-elements}
\end{figure}

The creation of such a Lagrange space in \dune[Fempy] is done by the
following code.

```python, label = 'space'
space = create.space('lagrange', grid, dimrange=1, order=2)
```

We comment once again on the arguments of the above function.

\begin{itemize}
  \item \pyth{'lagrange'} indicates that we will use a space with
  Lagrange basis functions.
  \item \pyth{grid} passes in the grid we constructed previously.
  \item \pyth{dimrange=1} (optional) sets the dimension of the range space to 1.
  \item \pyth{order=2} (optional) sets the order of the finite
  elements to 2.
\end{itemize}

Crucially, like before the first argument tells DUNE which class to
use for compilation. For instance this can be edited to use a discontinuous
Galerkin space with orthonormal basis functions instead by using
\pyth{'dgonb'}.

\subsection{Functions} \label{sec:functions}

Having defined the computational domain and function space, we look
towards functions that we may need to define, e.g. for containing the
solution. In particular we want to be able to store what initial
values it can take, its value at the previous timestep and so on.

Let us consider how the initial solution could be defined.
In \dune[Fempy], Unified Form Language (UFL) \cite{UFL} is used to define
equations, which is essentially a human-readable way of writing a
variational form. In order to use this we must define the UFL space
and necessary variables as follows.

```python, label = 'forch-uflx'
from dune.ufl import Space
from ufl import SpatialCoordinate
ufl_space = Space((grid.dimGrid, grid.dimWorld), 1)
x = SpatialCoordinate(ufl_space.cell())
```
\Atodo{doesn't Space(grid,1) work - and if it doesn't shouldn't it?}
\Atodo{should be try to make a discrete space behave like a ufl space so
       that if (like here) a discrete space is available we can simply
       write SpatialCoordinate(discreteSpace) and avoid the dune.ufl.Space
       all together?}
\Atodo{why are you not using the pweavecode environment here - you are
later on?}

Here we have created a \pyth{ufl_space} for UFL functions using the dimensions of
the grid for our domain space, and with the dimension of the range space set to 1 (i.e. scalar
functions). We also created \pyth{x} as a spatial coordinate to be used as
a variable in the next equation. So now for $\rho^0 =
\frac{1}{2}(x_0^2 + x_1^2) - \frac{1}{3}(x_0^3 - x_1^3) + 1$, we would
have the following code.
\Atodo{unmotivated use of $\rho$ here}

```python, label = 'forch-initial'
initial = 1/2*(x[0]**2 + x[1]**2) - 1/3*(x[0]**3 - x[1]**3) + 1
rho_h = space.interpolate(initial, name='rho_h')
```

So we have created a discrete function \pyth{rho_h} over the discrete
finite element space to contain the solution and
used an interpolation over the space to assign its initial value to
the UFL expression \pyth{exact}. The name is used later for plotting
purposes.

Having done this, a copy of this solution for the previous timestep,
\pyth{rho_h_n}, can be created quite easily.

```python, label = 'forch-rho_h_n'
rho_h_n = rho_h.copy()
```

In addition to this, functions that store the exact solution and
calculate the error will often be necessary to create. Say for
instance we want to look at the $L^2$ and $H^1$ errors for our computed solution
assuming an exact solution $u$ is known at the final time of the simulation:

\begin{equation}
 L^2\text{ error} = \int_{\Omega} | u - u_h |^2 \diff x, \qquad
 H^1\text{ error} = \int_{\Omega} | \nabla(u - u_h) |^2 \diff x.
\label{eqn:error}
\end{equation}

This can be achieved with the following code.

```python, label = 'error'
from ufl import as_vector, dot, grad, inner, exp
exact_end = as_vector( [exp(-2)*(initial - 1) + 1] )
l2error_gf = create.function('ufl', grid, 'l2error', 5, dot(rho_h-exact_end, rho_h-exact_end))
h1error_gf = create.function('ufl', grid, 'h1error', 5, \
                            inner(grad(rho_h-exact_end), grad(rho_h-exact_end)))
```
\Atodo{the 'ufl' functions are not really needed anymore - do we want to
show this here or directly go with the code given below?}
\Atodo{how about actually computing the error - showing the integrate
function - for the initial projection? Instead of \pyth{exact_end} you would of
course have to use 'initial'}

First of all we define the exact solution at the end time $T=1$,
\pyth{exact_end}. Then in this case we create the error functions on
the grid in a similar way to before by using UFL and \pyth{rho_h} and \pyth{exact_end}.

We note that this works even though \pyth{rho_h} is not a UFL expression
itself since the expression is extracted from it automatically. In
particular it is also possible in most cases to just use a UFL
expression directly. i.e.

\renewcommand{\pweavecaption}{Calculating the error without a function}
\renewcommand{\pweavelabel}{lst:error}
\begin{pweavecode}
l2error = dot(rho_h - exact_end, rho_h - exact_end)
h1error = inner(grad(rho_h - exact_end), grad(rho_h - exact_end))
\end{pweavecode}

\subsection{Schemes} \label{sec:schemes}

\Atodo{we need to be a bit more precise about what we mean with
'schemes' especially the 'solving' part is missing...}

Let us now consider how schemes could be implemented, which is to
say, the weak form of a PDE and its boundary conditions.

To see this applied to an example, let us consider a
nonlinear parabolic equation derived in \cite{Kieu}. The origin of
this equation stems from Darcy's law, an equation that describes flow
through porous media, and is applied regularly to groundwater flow
models.

\begin{equation}
  -\nabla p = \frac{\mu}{\kappa} v,
\label{eqn:darcy}
\end{equation}

where $p, v, \mu$ and $\kappa$ are the pressure, velocity, absolute
viscosity and permeability. For situations where the Reynolds number
is greater than ~10, inertia begins to have an effect on the system,
which isaccounted for in the Darcy-Forchheimer equation. In its most
general form we have the following.

\Atodo{I think describing the model here breaks the flow a bit? Would it be
better to have that a the beginning of the section? Perhaps there is also
too much detail here. Simply providing the final form without any
explanation is enough in this case?}

\begin{equation}
  -\nabla p = \sum^N_{i=0}a_i |v|^{\alpha_i}v,
\label{eqn:darcy-forch}
\end{equation}

where $a_i$ and $\alpha_i$ are obtained empirically. Through some
manipulations, we can simplify this to an equation for just the
pressure $\rho$.

\begin{equation}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f,
\label{eqn:forch}
\end{equation}

where the function $K: \mathbb{R}^{+} \to \mathbb{R}^{+}$ is dependent
on the $a_i$ and $\alpha_i$ above. Adding in boundary data and initial
values gives us the \textbf{boundary value problem}.

\begin{equation}
  \begin{array}{ll}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f & \mbox{in
  } \Omega \times [0, T], \\
  \rho(x, 0) = \rho^{0}(x) & \mbox{in } \Omega, \\
  K(|\nabla \rho|) \nabla \rho \cdot \textbf{n} + \phi(x) = 0 & \mbox{on }
  \Gamma \times [0, T],
  \end{array}
\label{eqn:forch-bvp}
\end{equation}

where $\rho^0$ and $\phi$ are initial and boundary data given. Thus
the \textbf{weak form} or variational formulation follows.

\begin{equation}
  (\rho_t, v_h) + (K(|\nabla \rho|) \nabla \rho, \nabla v_h) = - <
  \phi, v_h> + (f, v_h), \quad v_h \in V_h,
\label{eqn:forch-weak}
\end{equation}

with $\rho(x, 0) = \rho^{0}(x)$. Finally it remains to discretize the
equation in time using a backward Euler method. Let the time domain $I
= [0,T]$ be divided into $N$ intervals $t_0 = 0 < t_1 < \dots < t_N = T$
such that $\Delta t = t_n - t_{n-1}$ and $\rho^{n} = \rho(x, t_n)$.
Then we have the time discretized PDE.

\begin{equation}
  \left(\frac{\rho^{n+1} - \rho^{n}}{\Delta t}, v_h \right) +
  (K(|\nabla \rho^{n+1}|) \nabla \rho^{n+1},
  \nabla v_h) = - < \phi, v_h > + (f, v_h), \quad v_h \in V_h.
\label{eqn:forch-time}
\end{equation}

We note that this can be reaaranged into the form described in
(\ref{eqn:rothe}) (plus boundary term).

Now let us implement this numerically. To begin with, it is
necessary to define the variables that are used in the equation.

```python, label = 'forch-variables'
from ufl import TestFunction, TrialFunction, triangle
from dune.ufl import NamedConstant
rho = TrialFunction(ufl_space)
v = TestFunction(ufl_space)
dt = NamedConstant(triangle, "dt")    # time step
t  = NamedConstant(triangle, "t")     # current time
```

\Atodo{NamedConstant is an extension to ufl which needs explaining...}

The trial function $\rho$ and the test function $v$ are defined on the
same FEM space as before, \pyth{ufl_space}. Additionally
$\Delta t$ and $t$ are defined as \pyth{Constant} so that their values
can be set later on in the program.

Now for the equation (\ref{eqn:forch-time}) itself, let us prescribe
the following value for $K$, and $\phi$.
\begin{equation}
  K(x) = \frac{2}{1+\sqrt{1+4x}}, \qquad \phi = 0.
\label{eqn:parameters}
\end{equation}

This results in an implementation of the following form.

```python, label = 'forch-eqn-impl'
from ufl import dx, sqrt
abs_drho = sqrt(inner(grad(rho), grad(rho)))
K = 2/(1 + sqrt(1 + 4*abs_drho))
a = (inner((rho - rho_h_n)/dt, v) + inner(K*grad(rho), grad(v)))*dx
```

For the exact solution we will use the following (which is consistent
with the initial data).
\begin{equation}
  \rho(x,t) = e^{-2t}\left(\frac{1}{2}(x_0^2 + x_1^2) -
  \frac{1}{3}(x_0^3 - x_1^3)\right) + 1
\label{eqn:exact}
\end{equation}

We can use \pyth{initial} to define this without much effort.
```python, label = 'forch-exact'
exact = exp(-2*t)*(initial - 1) + 1
```

To set the right hand side of the equation, i.e. $f$, we put the
exact solution into the left hand side of the PDE as follows.
%\Ltodo{Would like strong form here but it's not currently working}

```python, label = 'forch-rhs'
from ufl import replace
exact = as_vector([exp(-2*t)*(initial - 1) + 1])
b = replace(a, {rho: exact})
```

Having defined the bilinear form and right hand side, we can now set
up a scheme object which we can use to solve the PDE.

```python, label = 'forch-scheme'
scheme = create.scheme("h1", space, a == b, solver='cg')
```

The above function creates a simple Galerkin method for $H^1$
conforming elements, with the space and equation passed in. As before
there exist other such premade \dune schemes for different problems.
For instance \pyth{'dg'} is used for discontinous Galerkin methods,
\pyth{'stokes'} for Navier-Stokes problems, etc.
\Atodo{'stokes' is probably not functional at the moment - again perhaps
simply a forward reference is enough?}

Additionally the solver can be specified, so for this instance we use
\pyth{'cg'} for a conjugate gradient method, since the PDE is symmetric.

Lastly we note that it is possible to explictly define a model object
to hold the solution, and we investigate the different ways of doing
this in section \ref{sec:header}.

\subsection{Solving} \label{sec:solving}

The last natural part of a FEM is the solving, which includes
time loops, mesh refinements, data output and plotting, and so on.
Let us begin by setting up the time variables. Since the problem is time-dependent, we
solve over a for loop with $t_0 = 0, t_N = 1$ and $\Delta t = 0.05$.

```python, label = 'forch-pre-solve'
from math import log
timeStep = 0.05
endTime = 1.0
scheme.model.dt = timeStep
```

We also compute the estimated order of convergence (EOC), to test our
method.

\begin{equation*}
  EOC = \frac{\log(e_{new}/e_{old})}{\log(h_{new}/h_{old})}.
\label{eqn:eoc}
\end{equation*}

This is calculated by refining the grid and comparing the errors
($e_{old}$ and $e_{new}$) to the grid sizes ($h_{old}$ and
$h_{new}$), where the errors are computed using the error function
\pyth{l2error_gf} from \ref{eqn:error}. In particular for a grid size
that is being halved at each step, we do the following after each
solve step.

\renewcommand{\pweavecaption}{Calculating the EOCs}
\renewcommand{\pweavelabel}{lst:eoc}
\begin{pweavecode}
error_old = error                        # set the previous error
error = sqrt(l2error_gf.integrate()[0])  # integrate the L^2 error function
eoc = log(error/error_old)/log(0.5)      # do the eoc calculation
grid.hierarchicalGrid.globalRefine(2)    # refine the grid twice
\end{pweavecode}

If desired, lines can be added to plot the data visually. The two main ways to do
this in Fempy are either a quick plot in \pyth{matplotlib}, or writing to a
VTK file for use in Paraview, as follows.

\renewcommand{\pweavecaption}{Two methods for plotting data}
\renewcommand{\pweavelabel}{lst:plot}
\begin{pweavecode}
plot(rho_h)
grid.writeVTK('forchheimer', pointdata=[rho_h, l2error_gf, h1error_gf])
\end{pweavecode}

Combining these concepts into one solve method in Fempy, we have the
following program.

```python, label='forch-main', fig=True, caption='Plot of solutions at each level of refinement', width='0.32\\textwidth'
error = 0
for eocLoop in range(3):
    print('# step:', eocLoop, ', size:', grid.size(0))
    time = 0.0
    rho_h.interpolate(initial)
    while time < (endTime + 1e-6):
        scheme.model.t = time
        rho_h_n.assign(rho_h)
        scheme.solve(target=rho_h)
        time += timeStep
    error_old = error
    error = sqrt(l2error_gf.integrate()[0])
    if eocLoop == 0:
        eoc = '-'
    else:
        eoc = log(error/error_old)/log(0.5)
    print('|rho_h - rho| =', error, ', eoc =', eoc)
    plot(rho_h)
    grid.writeVTK('forchheimer', pointdata=[rho_h, l2error_gf,
    h1error_gf], number=eocLoop)
    grid.hierarchicalGrid.globalRefine(2)
```

We compile a table of the errors and eocs for additional refinement
steps and a smaller timestep of $\Delta t = 0.001$ below.

\begin{center}
  \begin{tabular}{l | l | l | l | l}
    \hline
    Elements & $\|u - u_h\|_{L^2}$ & EOC & $|u - u_h|_{H^1}$ & EOC \\ \hline
    32 & 2.846e-05 & - & 9.128e-04 & - \\
    128 & 3.526e-06 & 3.0128 & 2.051e-04 & 2.154 \\
    512 & 4.605e-07 & 2.937 & 5.122e-05 & 2.002 \\
    2048 & 5.884e-08 & 2.968 & 1.282e-05 & 1.998 \\
    8192 & 1.605e-08 & 1.874 & 3.210e-06 & 1.998
  \end{tabular}
\end{center}

%\Ltodo{Add example 2, rerun for smaller timestep to fix last eoc}

\section{Header Files and Usage in C++} \label{sec:header}

Now that we have introduced each component of the Fempy structure, let
us now look more in-depth into some of the features and design decisions
behind it.

We briefly alluded to a way of creating an operator independent of a
scheme in section \ref{sec:schemes}, so let us expand upon this idea here.
We can separate the process into two steps as follows.

\renewcommand{\pweavecaption}{A simple elliptic operator}
\renewcommand{\pweavelabel}{lst:elliptic}
\begin{pweavecode}
model = create.model('elliptic', grid, a == b)
scheme = create.scheme("h1", space, model)
\end{pweavecode}

where \pyth{a == b} refers to the UFL expression used to represent the
bilinear form, and \pyth{'elliptic'} refers to the elliptic operator
class in \dune. The purpose of this class is to represent the standard
structure of what we consider of what we consider is necessary for an
elliptic PDE model, by having a set list of virtualized methods. This
is then implemented in \dune[Fempy] by translating the UFL input into a \dune class compatible
format.

We note that this is a different approach to similar packages, which
in general do not create a virtual class and instead use the UFL form
directly. In fact such an approach is also available in \dune[Fempy],
using the \pyth{'integrands'} identifier. Each version comes with its
own advantages and disadvantages, which is what we would like to
discuss in this section.

First let us consider the default elliptic model. In mathematical
terms, we consider the following operator.

\begin{equation*}
  L[u] = \nabla \cdot D(x, u, \nabla u) \nabla u(x) + m(x, u, \nabla u).
\end{equation*}

In variational form, after multiplying with a test function and
integration by parts (ignoring boundary terms for now), we arrive at

\[
  \int_{\Omega}D(x, u, \nabla u) \nabla u \cdot \nabla v + m(x, u, \nabla u)
  v \diff x.
\]

Now the elliptic model class in Fempy has methods that represent these
general expressions. Suppose for
instance we were to take the case of $m(x, u, \nabla u) = u$ above. In
\dune, this would be defined under the method \cpp{source}.

\renewcommand{\pweavecaption}{A function in the elliptic operator C++
class}
\renewcommand{\pweavelabel}{lst:elliptic-cpp}
\begin{pweavecode}
template< class Point >
void source ( const Point &x, const RangeType &u, const JacobianRangeType &du, RangeType &result ) const
{
  result[ 0 ] = u[ 0 ];
}
\end{pweavecode}

A similar method exists for $D(x, u, \nabla u)$, as well as linearized
versions for the purposes of nonlinear methods. Addtionally there are
methods for the associated Dirichlet or Neumann boundary conditions.
Together these form the elliptic operator class which is the
default way of expressing bilinear forms in \dune[Fempy]. Generally this
class is then used to create a shared object file that is exported to
python using Pybind11 for use in python scripts and notebooks.

We would like to highlight however, that an alternate way to use this
C++ class exists in the form of header files. That is, it is possible
to generate a C++ header file (e.g. \cpp{'operator.hh'}) that can be
used flexibly in both Fempy and regular \dune code. This can be done
simply by adding in an additional argument to the previous method.

\renewcommand{\pweavecaption}{Header file generation}
\renewcommand{\pweavelabel}{lst:header}
\begin{pweavecode}
model = create.model('elliptic', grid, a == b, header='operator.hh')
\end{pweavecode}

Such a file can then be edited manually in C++, and then used in place
of a UFL expression in Fempy. This ability to create header files falls in line with
attempts we have made to improve extensibility of the code, since in
particular it allows for the user to write in more complex features that do
not necessarily have python bindings written for them.

Another possibility provided for by the modular design of
\dune[python] (cite here) and the elliptic class structure is the creation of alternate
operators. This approach involves the writing of additional C++
classes (one example would be a discontinuous Galerkin elliptic operator) based on
the elliptic operator class except with extra modifications that one
might want to make to the underlying structure.
Whilst this approach is more in-depth than simply editing
an elliptic header file, it allows one to change the functions
themselves beyond what the default elliptic operator accepts.

An example of this approach is the nonvariational operator designed
for the \dune[femnv] module. This comes from the desire to write
bilinear forms that can accept a Hessian operator as follows.

\begin{equation*}
  L[u] = \nabla \cdot D(x, u, \nabla u) \nabla u(x) + m(x, u, \nabla
  u, D^2 u).
\end{equation*}

Such a change would require different arguments to be made available
to the methods from the elliptic operator. Suppose we wanted to
implement the nonvariational Poisson equation, i.e. taking $m = -\Delta u$
above. Then we would need the following method.

\renewcommand{\pweavecaption}{A nonvariational operator}
\renewcommand{\pweavelabel}{lst:nvop}
\begin{pweavecode}
template< class Point >
void source ( const Point &x, const RangeType &u, const
JacobianRangeType &du, const HessianRangeType &d2u, RangeType &result ) const
{
  result[ 0 ] = d2u[ 0 ][ 0 ] + d2u[ 1 ][ 1 ];
}
\end{pweavecode}

Whilst this may not be immediately possible with the standard elliptic
operator, it is possible to create an operator \cpp{'nvdg'} that can
use such functions, which results in the ability to write functional
\dune[Fempy] code as follows.

\renewcommand{\pweavecaption}{The Fempy code for an nonvariational operator}
\renewcommand{\pweavelabel}{lst:fempy_nv}
\begin{pweavecode}
a = -(grad(grad(u[0])[0])[0] + grad(grad(u[0])[1])[1])*v[0]*dx
b = rhs(A, exact)
model = create.model("nvdg", grid, a == b)
\end{pweavecode}

Thus it becomes possible to write schemes that expect different
arguments from the operator.

We note however that as mentioned before, there exists another way of
constructing operators, by using \pyth{'integrands'}. This method
bypasses the virtual methods used in the elliptic operator class and
creates methods purely using the UFL expressions given to it. This
again allows for expressions that are not by default allowed in the
default elliptic class, as shown below.

\renewcommand{\pweavecaption}{Usage of integrands operators for
skeleton terms}
\renewcommand{\pweavelabel}{lst:fempy_integrands}
\begin{pweavecode}
a = -(grad(grad(u[0])[0])[0] + grad(grad(u[0])[1])[1])*v[0]*dx
    + jump(A*grad(u[0]), n)*avg(v[0])*dS
b = rhs(A, exact)
scheme = create.model("integrands", space, a == b)
\end{pweavecode}

Here we take the nonvariational equation from before and add a term
defined only on the skeleton (the edges) of the mesh.

\Ltodo{efficiency comparison? this requires writing a test
case}

\section{Storage Types and SciPy}

We carry on our explanation of different \dune[Fempy] features by
looking at the different storage backends available.
We will continue to do so in the context of a worked examples
that demonstrate the practicality of these features.

We can specify the storage type as follows.

\renewcommand{\pweavecaption}{Accessing different storage types}
\renewcommand{\pweavelabel}{lst:storage}
\begin{pweavecode}
space = create.space('lagrange', grid, dimrange=1, order=2, storage='istl')
\end{pweavecode}

As before we assemble the space, but now with the additional argument
that specifies the usage of \dune[Istl] as a linear algebra backend. Changing the
\pyth{storage} argument in the construction of the space makes
it possible to use more sophisticated solvers (either better
preconditioners or direct solvers). Other possibilites include
\pyth{'fem'}, \pyth{'eigen'} and \pyth{'petsc'} for the \dune[Fem], Eigen and PETSc packages.

In particular one thing that we can do with certain storage methods is integrate SciPy methods into our code. This
allows for more complex ways of writing numerical methods without the
need to explicitly write this on the C++ side.
We will show that it is possible to store the degrees of freedom in such a way that
they can be treated as NumPy vectors and an assembled system matrix
can be stored in a SciPy sparse matrix.

Since we will be implementing a Newton solver first, let's study a
truly nonlinear problem - a version of the p-Laplace problem.
\begin{gather}
  - \frac{d}{2}\nabla\cdot |\nabla u|^{p-2}\nabla u + u = f.
\end{gather}

We start with the basic setup in the same way as in
section \ref{sec:fem-in-fempy}.

\input{laplace-la.tex}

One other thing we can do is assemble PDE systems on the python side
by using SciPy. For instance suppose we had a system of PDEs of the form

\[
\left( \begin{array}{cc}
  A & B \\
  B^T & C \end{array} \right)
  \left( \begin{array}{c}
  \textbf{u} \\
  \textbf{w} \end{array} \right)
  = \left( \begin{array}{c}
  \textbf{f} \\
  \textbf{g} \end{array} \right).
\]

If we have access to the schemes that represent $A, B$ and $C$, this
is easy to set up. First we can individually assemble the matrices from the schemes
and combine them into one matrix as follows.

\renewcommand{\pweavecaption}{Assembling matrices}
\renewcommand{\pweavelabel}{lst:assemble}
\begin{pweavecode}
from scipy.sparse import bmat
A  = scheme_a.assemble(uh)
B  = scheme_b.assemble(uh)
BT = B.transpose(copy=True)
C  = scheme_c.assemble(uh)
system = bmat([[A, B], [BT, C]])
\end{pweavecode}

Then one can construct a RHS using the residuals from the schemes in a
similar way to below.

\renewcommand{\pweavecaption}{Assembling the right hand side}
\renewcommand{\pweavelabel}{lst:rhs}
\begin{pweavecode}
import numpy as np
wh = uh.copy()
f = uh.copy()
g = uh.copy()
uh_coeff = uh.as_numpy
wh_coeff = wh.as_numpy
f_coeff = f.as_numpy
g_coeff = g.as_numpy
scheme_a(uh, f)
f_coeff *= -1
scheme_c(uh, g)
g_coeff *= -1
rhs = np.concatenate((f_coeff, g_coeff))
sol = np.concatenate((uh_coeff, wh_coeff))
\end{pweavecode}

Finally the system can simply be solved using a CG solver.

\renewcommand{\pweavecaption}{Solving the system using SciPy}
\renewcommand{\pweavelabel}{lst:scipy-solve}
\begin{pweavecode}
from scipy.sparse.linalg import cg
sol, info = cg(system, rhs)
\end{pweavecode}


\Ltodo{should have something about petsc capabilities}

\section{Adaptive Mesh Refinement}

For our next example we consider adaptive mesh refinement applied to a model
for crystal growth. Adaptive mesh refinement is a technique that
allows for the targeted refinement of the computational domain in
specific areas where there is greater turbulence or activity, for greater
precision. In problems where uniform refinement of a mesh is not
required, this allows for more precision of the results at less
computational cost.

The method considered here uses so-called h-adaptivity that adds
additional mesh points to the grid at areas of small scale activity.
It does so based on a marking procedure that
evaluates the gradient of the solution at each element and determines
whether to refine the grid based on a level of tolerance.

\input{crystal.tex}
\section{Moving Meshes}
Here we look at moving surfaces using a mean curvature flow problem.
\input{mcf.tex}
\section{Multi-domain Grids}
Here we look at multi-domain grids using this battery problem.
\input{battery.tex}
%</tag>
\section{Code (placeholder)}

\inputpython{../../dune-fempy/demo/forchheimer.py}{}{lst:forch-file}

\bibliographystyle{abbrvnat}
\bibliography{dune-fempy}

\end{document}
