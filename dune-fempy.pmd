\documentclass{ansarticle}

\definecolor{hrefcolor}{rgb}{0.0,0.0,0.8}
\newcommand{\linkcolor}{hrefcolor}
\hypersetup{pdfstartview=FitR}
\hypersetup{pdftitle={The DUNE-Fempy Module},
            pdfauthor={L. Connellan, A. Dedner, M. Nolte},
            breaklinks=true,
            linkbordercolor=\linkcolor,
            urlbordercolor=\linkcolor,
            citebordercolor=\linkcolor,
            runbordercolor=\linkcolor,
            menubordercolor=\linkcolor,
            filebordercolor=\linkcolor,
            runcolor=\linkcolor
            baseurl={https://gitlab.dune-project.org/extensions/dune-alugrid}
}
% make links underlined in acrobat reader
\hypersetup{pdfborderstyle={/S/U/W 1}}
\newcommand*\diff{\mathop{}\!\mathrm{d}}

%<*pre>
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{anslistings}
\usepackage{subcaption}
\usepackage{xspace}

\newcommand{\dune}[1][]{\textsc{Dune}\ifx&#1&\else\textsc{-{#1}}\fi\xspace}
\newcommand{\alugrid}{\textsc{ALUGrid}\xspace}
\newcommand{\ug}{\textsc{UG}\xspace}
\newcommand{\sionlib}{\textsc{SIONlib}\xspace}
\newcommand{\alberta}{\textsc{ALBERTA}\xspace}
\newcommand{\yaspgrid}{\textsc{YaspGrid}\xspace}

\newcommand{\matplotlib}{\pyth{Matplotlib}\xspace}
\newcommand{\quadpy}{\pyth{Quadpy}\xspace}
\newcommand{\numpy}{\pyth{Numpy}\xspace}
\newcommand{\scipy}{\pyth{Scipy}\xspace}
\newcommand{\paraview}{Paraview\xspace}
\newcommand{\vtk}{VTK\xspace}
\newcommand{\cmake}{cmake\xspace}
\newcommand{\pybind}{Pybind11\xspace}
\newcommand{\code}[1]{\lstinline[basicstyle=\small\sffamily]{#1} }
\newcommand{\file}[1]{\code{#1}}

\newcommand{\Atodo}[1]{\todo[inline]{{\bf\color{green}Andreas:} #1}}
\newcommand{\Ltodo}[1]{\todo[inline]{{\bf\color{blue}Lloyd:} #1}}
\newcommand{\Mtodo}[1]{\todo[inline]{{\bf\color{green}Martin:} #1}}

\newcommand{\autocite}{\cite}
%</pre>
\newcommand{\pweavecaption}{}
\newcommand{\pweavelabel}{}
\lstnewenvironment{pweavecode}[1][]{\lstset{escapechar=`,moredelim=[il][]{\#tex},style=pythonstyle, title={\codetitlestyle{Python code }},belowcaptionskip=\belowtitleskip, caption=\pweavecaption,label=\pweavelabel}}{}
\lstnewenvironment{pweaveout}[1][]{\lstset{style=gencodestyle, title={\codetitlestyle{Output}}, belowcaptionskip=\belowtitleskip}}{}

\begin{document}

\title{The \dune[Fempy] Module}
\author[1]{Lloyd Connellan}% \thanks{l.connellan@warwick.ac.uk}}
\author[2]{Andreas Dedner}% \thanks{a.s.dedner@warwick.ac.uk}}
\author[3]{Martin Nolte}%\thanks{nolte@mathematik.uni-freiburg.de}}
\affil[1]{University of Warwick, UK}
\affil[2]{University of Warwick, UK}
\affil[3]{University of Freiburg, Germany}
\runningtitle{The \dune[Fempy] Module}
\runningauthor{Connellan, Dedner, Nolte}

\providecommand{\keywords}[1]{\textbf{Keywords: } #1}

\date{November, 2017}

\maketitle

Remove the following from the final tex output - leave in now so that
ptangle works
```python, label = "intro"
import time
import numpy
import math
import dune.plotting
dune.plotting.block = False
```

\begin{abstract}
In this paper we present the new \dune[Fempy] module...

\noindent
\keywords{..., \dune}
\end{abstract}

\tableofcontents

\section{Introduction}

%<*intro>

Among the different numerical methods for solving partial differential
equations, finite element methods are one of the most popular. They have been used
for a broad range of engineering and scientific problems, with the first
computational applications originating as early as 1956 in \cite{Turner}. Over the
years there has been an extensive amount of literature analyzing FEMs
in general and their uses (see \cite{Khoei} and \cite{Babuska}).

Just as the development of the theory of FEMs has progressed over the years,
the landscape of FEM software itself has undergone much change.
As a multidisciplinary method involving many different techniques, the
scope for which direction to develop features is very high. Even
within the realm of standard FEMs there exist a multitude of different
options available. For instance with regards to types of finite
elements, if one considers \textit{conforming} finite elements
(i.e. where $V_h \subset V$) then one has possibilies such as the
well-known Lagrange element, the $H(div)$ conforming
Brezzi-Douglas-Marini element (used for e.g.
the elastic stress tensor), the $H(curl)$ conforming N\'{e}d\'{e}lec element (used in
electromagnetism), and so on. Then (provided one uses a penalty
method) one can further expand this to have nonconforming elements such as the $H^2$
Hermite (cubic) elements, the Morley (quadratic) elements (used for fourth order
problems), and the $H^1$ Crouzeix-Raviart element (used in e.g. Stokes
equations)\footnote{For a more complete list see \cite{FEniCS2}}. We
then note that with regards to the mesh itself, one can
have structured grids that are more computationally efficient or
unstructured ones that allow for more flexibility. Or one could
have different shapes such as squares, triangles, cubes, pyramids,
hexahedrons and so on. This is all without going into more complex
forms of FEM such as hp-FEM, spectral element methods and extended
finite element methods (XFEM).

This diversity of choice has lead to the situation of numerous
competing packages that offer slightly different
flavours of FEM. One preventative measure to this has been the
development of large modular software libraries that offer many
optional extensions in one place, thus forgoing the need to install
different packages for different problems. Such examples include \dune
(\cite{Dune-Grid}), deal.II (\cite{dealII}), FreeFem++
(\cite{FreeFem}) and Elmer (\cite{Elmer}). These large packages are
typically written in languages such as C++ and Fortran that are
efficient for large-scale computations.

In recent years however there has been a trend towards packages that
favour usability, especially given the rise in popularity of python as
a programming language. Such packages ideally look to lower the
learning curve for new developers and non-computer focused
researchers, without compromising the functionality and efficiency of
traditional packages. An additional benefit to using python is the
facilitating of rapid prototyping, which allows one to quickly
construct new models and test their viability without having to write
an intricate program. In particular FEniCS (\cite{FEniCS}) and Firedrake
(\cite{Firedrake}) are examples of this kind of software. Integral to this approach has
been using a simplfied interface attached to a backend with lower
level code, which is typically achieved by an automatic code
generation tool like SWIG or Cython.

In particular the use of Unified Form Language
(UFL) (\cite{UFL}), a domain-specific language (DSL),
allows one to write variational equations directly. For instance
for Poisson's equation we have
\renewcommand{\pweavecaption}{Poisson's equation in UFL}
\renewcommand{\pweavelabel}{lst:poisson}
\begin{pweavecode}
a = inner(grad(u), grad(v))*dx
b = inner(f, v)*dx
\end{pweavecode}
Nonetheless there are potential weaknesses in the code generation
approach. In particular this generated code is not
suited to direct editing, so should a binding not exist for a feature
on the python side, editing these generated files to add the feature
on the C++ side is not an option. Furthermore, user interactibility with the
C++ interface is not prioritized, which means porting code over to C++
for efficiency reasons or the writing of additional features are not
viable.

In this paper we introduce \dune[Fempy], a \dune module that is an
extension to \dune[Python] (\cite{Dune-Py}) specifically aimed at
adding high-level FEM features based on the \dune[Fem] module
(\cite{Dune-Fem}) to \dune. The aim of both of these packages is to bring the
usability and speedier writing of code to \dune and its large array of existing modules,
whilst preserving the features available to a C++ developer. In
particular the structure and functionality is designed to be analagous
in many ways to \dune code, making it less difficult to port code to
C++ if necessary. Additionally, attempts to increase usability have been
made, such as library caching to reduce the runtime of repeated computations, and
integration with modern C++11/C++14 via pybind11 (see
\cite{Pybind11}) to interface between C++ and python.

%</intro>

The structure of the paper is as follows. In section
\ref{sec:fem-in-fempy} we introduce the interface for a simple
FEM step-by-step. In sections \ref{sec:solve} and \ref{sec:header} we
look more in-depth at this example and some of the design flexibility
available. In sections \ref{sec:crystal}, \ref{sec:mcf} and \ref{sec:battery} we
look at additional features in the context of more complex examples.
Finally we discuss the comparison to C++ code in section
\ref{sec:mcf-comparison}.

\Atodo{depending on the journal we would need to describe a bit about the
technical side:
(1) generator (2) create mechanism since it is heavily used here.
The first could be a more technical description taken from the python paper
the later would be new. If we want to try TOMS then perhaps having the
HTTP generator?}
\Atodo{do we want to add something on parallelism}
\Atodo{which other features are missing? Should we include an example on
non variational problems or bounding box dg? Perhaps we could show r
adaptivity (also shows off the moving grid capability) and the use of
dune-femnv?}

%<*tag>

\section{Finite Element Methods in Fempy} \label{sec:fem-in-fempy}
```python, label="fem-in-fempy", echo=False
# <markdowncell>
# ## Finite Element Methods in Fempy
# In this section we introduce the basic components of a finite
# element method when applied to the Forchheimer problem.
# <codecell>
```

When designing any software package, a natural challenge that arises
is trying to make the user interface as simple and easy to use as possible.
At the same time however, we also want to create an interface that retains
all the functionality we need.

In the context of finite element methods (FEMs), this leads to the question
of what the minimal functional structure for a FEM looks like. In
order to try to address this question, we will first outline from a
mathematical standpoint the general structure we have in mind for a
FEM.

To begin with, the original problem we typically want to apply a finite
element method to is a continuous PDE in some
infinite-dimensional space $V$. First let $\Omega \subset \mathbb{R}^d$ be
a polygonal domain for our problem. We then choose a conforming
finite element space $V_h = \{\varphi_h : \Omega \to \mathbb{R}^r \}
\subset V$, where dim $V_h = N$. This involves choosing a basis for
$V_h$, which can vary depending on the problem, but typically involves
piecewise polynomial functions.

Next the variational (or weak) form of the equation is defined. For
the purpose of illustration, let us assume to start with we have a
parabolic PDE of the following general form.

\begin{equation*}
  \begin{array}{ll}
  \partial_t u + L[u] = 0 & \mbox{in } \Omega \times [0, T], \\
  u(x, 0) = u^0(x) & \mbox{in } \Omega, \\
  D \cdot \textbf{n} = g(x) & \mbox{on } \Gamma \times [0, T],
  \end{array}
\label{eqn:parabolic}
\end{equation*}

where the elliptic operator L is defined as

\begin{equation}
  L[u] := -\nabla \cdot D(x, u) + m(x, u, \nabla u).
\label{eqn:elliptic}
\end{equation}

and $u^0$ and $g$ are the initial and boundary conditions and
$\textbf{n}$ is the outward pointing normal. We note that we are
only considering Neumann boundary conditions here for simplicity,
although Dirichlet boundary conditions are also a possibility. The
variational form is then obtained in the usual way by multiplying by a
test function $\varphi \in V_h$, integrating by parts and discretizing
in time. After applying a simple time stepping schmee, this leads to
methods that take the following form.

\begin{equation}
  \int_{\Omega} u^{n+1} \varphi + \Delta t L_I[u^{n+1}] \diff x =
  \int_{\Omega} u^n \varphi + \Delta t L_E[u^n] \diff x + \Delta t \int_{\Gamma} g(x)
  \varphi \diff s.
\label{eqn:rothe}
\end{equation}

where $L_I$ and $L_E$ are the implicit and explicit parts of $L$,
defined as
\begin{gather}
  L_I[u] = D_1(x, u \nabla u) \cdot \nabla \varphi + m_1(x, u, \nabla u) \varphi, \quad \\
  L_E[u] = D_2(x, u \nabla u) \cdot \nabla \varphi + m_2(x, u, \nabla u) \varphi,
\label{eqn:im-ex}
\end{gather}

and $D_1 -D_2 = D$, $m_1 - m_2 = m$. The last step is to
solve this system for $u^{n+1} \in V_h$. This also
involves potential variation in terms of the solver used and possible
nonlinearity of the problem. We also note that this is a simple scheme
for demonstration, and more complex examples involving higher order
schemes or nonconforming spaces can be easily implemented along the
same lines.

With this general form in mind, in \dune[Fempy] we have designed the
structure to take as similar a style as possible, which results in the
following breakdown of parts.

\begin{itemize}
  \item \ref{sec:grids} Grid. The computational domain $\Omega$ the problem is set in.
  \item \ref{sec:spaces} Space. The finite element space $V_h$ and type of basis functions.
  \item \ref{sec:functions} Functions. Functions defined on the grid that store the
  solution $u_h$ and other variables.
  \item \ref{sec:schemes} Scheme. The weak form of the equation, its
  boundary conditions, and method for solving.
  \item \ref{sec:solving} Solving. The actual solving process and data
  output.
\end{itemize}

We note that there exist even further simplifications that can be made
in terms of this design choice; for instance a FEM could be
distilled to simply choosing a bilinear form (an operator) and a grid,
and having all other things set to sensible defaults. Additionally the code
itself used to represent these methods could be simplified to a large
degree depending on the aim of the software.

Ultimately as a FEM package aimed more at extensibility and for
researchers who are willing to commit to some degree of
programming, we have opted for more complexity in some cases at the
expense of this simplicity. In general this is quite a nuanced design
decision that must be made without a clear \textit{right} answer.

With that in mind, for the remainder of this section we shall
demonstrate in more detail how each of these concepts are implemented
in the context of a worked example, the FEM applied to
the Forchheimer equation, a scalar,
nonlinear parabolic equation derived in \cite{Kieu}. A full derivation
of this equation is described in appendix \ref{sec:forch}, but for the
following the final form (\ref{eqn:rothe}) suffices:

\begin{equation} \label{eqn:forch-roche}
  \int_{\Omega} u^{n+1} v + \Delta t K(\nabla u) \nabla u^{n+1} \cdot
  \nabla v \diff x = \int_{\Omega} u^n v + \Delta t f
  v \diff x.
\end{equation}

\subsection{Grids} \label{sec:grids}

The first aspect of FEMs that we consider is probably the most
fundamental aspect, that of the grid (or mesh). Naturally, before looking at the
equations we want to solve themselves, we must look at the
computational domain and how we want to discretize it. Ideally
numerical software looking to emulate FEMs should be able to construct both simple
triangulated 2D domains and more complex surfaces and meshes.

For now we will look at a simple example. Let us suppose we
have a domain of the following form.

\begin{equation*}
  \Omega = \{ (x,y) \in \mathbb{R}^2 : 0 \leq x \leq 1, 0 \leq y \leq 1\}.
\label{eqn:domain}
\end{equation*}

In creating a computational grid for this domain, it will be necessary to specify
the following things.

\begin{enumerate}
  \item The shape (a square) and its vertices.
  \item The number of elements.
  \item The type of elements (squares? triangles?).
\end{enumerate}

With these points in mind, we implement the grid in the following way
in \dune[Fempy] and plot the result.

\renewcommand{\pweavecaption}{Creating and plotting two simple
rectangular grids}
\renewcommand{\pweavelabel}{lst:grid}
```python, label="grid", fig=True, caption="Plot of a 2D grid for two different levels of refinement", width="0.475\\textwidth"
from dune.grid import structuredGrid
grid = structuredGrid([0, 0], [1, 1], [4, 4])
grid.plot()
grid.hierarchicalGrid.globalRefine(1)
grid.plot()
grid.hierarchicalGrid.globalRefine(-1)  # return grid to original state
```

Here we create a simple square domain by specifying two opposite
corners $(0,0)$ and $(1,1)$, and the number
of elements in each direction $(4,4)$. We then refine the grid and
plot the results, before coarsening it again. We note that this is a
simplfied example and in general grids in Fempy can
additionally be constructed via a dictionary containing vertex and
element information, gmsh files or \textit{dune grid format} (dgf)
files when more complexity is required, which is demonstrated in the
\dune[python] paper \cite{Dune-Py}. A list of more complicated
grids and other modules is given in \ref{sec:modules}.

Conceptually it is worth stating that from a design standpoint, assumptions
could potentially be made to cut down on the complexity needed.
For instance in situations where the exact details are
not necessary, a basic square grid could simply be made with
\pyth{grid = square()}. However such a design comes at the cost of it
being unclear how to make small modifications.

\subsection{Spaces} \label{sec:spaces}

The next key part of a FEM after constructing the grid is defining the
kind of elements we want to use, and by extension their space. In
particular this is important because the order of elements used can
dictate the solvability and the efficiency of the method.

Let us consider a simple case of Lagrange elements. Since we have a 2D
domain with a quadrilateal mesh, we consider shape functions that are 1 on
each separate node (shown in \ref{fig:lagrange-elements}), and 0 on
the others. For orders 2 and 3, the shape functions would be quadratic
and cubic polynomials respectively.

\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.4\linewidth]{figures/lagrange-ele2.jpg}
  \caption{Second order element}
  \label{fig:lagrange2}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.4\linewidth]{figures/lagrange-ele3.png}
  \caption{Third order element}
  \label{fig:lagrange3}
\end{subfigure}
\caption{Node maps of two Lagrange reference elements}
\label{fig:lagrange-elements}
\end{figure}

The creation of such a Lagrange space in \dune[Fempy] is done by the
following code.

\renewcommand{\pweavecaption}{Creating a Lagrange space with
polynomial basis functions}
\renewcommand{\pweavelabel}{lst:space}
```python, label = 'space'
import dune.create as create
space = create.space('lagrange', grid, dimrange=1, order=2)
```

We note that the above space is called with two default
arguments and two keyword arguments.

\begin{itemize}
  \item \pyth{'lagrange'} indicates that we will use a space with
  Lagrange basis functions.
  \item \pyth{grid} passes in the grid we constructed previously.
  \item \pyth{dimrange=1} (optional) sets the dimension of the range
  space to 1 (deduced from the UFL expression by default).
  \item \pyth{order=2} (optional) sets the order of the finite
  elements to 2 (2 is the default).
\end{itemize}

Of particular note is that the first argument corresponds to a \dune
discrete space realization that can come from anywhere within a \dune
installation, provided python bindings are created for it. For instance we could use a
discontinuous Galerkin space with orthonormal basis functions instead
by using \pyth{'dgonb'}.

\subsection{Functions} \label{sec:functions}

Having defined the computational domain and function space, we look
towards functions that we may need to define, e.g. for containing the
solution. In particular we want to be able to store what initial
values it can take, its value at the previous timestep and so on.

Let us consider how the initial solution could be defined.
In \dune[Fempy], Unified Form Language (UFL) \cite{UFL} is used to define
equations, which is essentially a human-readable way of writing a
variational form. In order to use this we must begin by defining the
variables in the following way.

\renewcommand{\pweavecaption}{Creating an \pyth{x} variable in UFL}
\renewcommand{\pweavelabel}{lst:forch-uflx}
```python, label = 'forch-uflx'
from ufl import SpatialCoordinate
x = SpatialCoordinate(space)
```

Here we create \pyth{x} as a spatial coordinate from UFL by using the
\pyth{space} object from the previous section. The \pyth{space} gives
UFL the dimensions of the grid and the range space, so it knows
\pyth{x} is two dimensional. So now for initial condition $u =
\frac{1}{2}(x_0^2 + x_1^2) - \frac{1}{3}(x_0^3 - x_1^3) + 1$, we would
have the following code.

\renewcommand{\pweavecaption}{Interpolating a discrete function from
intial data}
\renewcommand{\pweavelabel}{lst:forch-initial}
```python, label = 'forch-initial'
initial = 1/2*(x[0]**2 + x[1]**2) - 1/3*(x[0]**3 - x[1]**3) + 1
u_h = space.interpolate(initial, name='u_h')
```

So we have created a discrete function \pyth{u_h} over the discrete
finite element space to contain the solution and
used an interpolation over the space to assign its initial value to
the UFL expression \pyth{exact}. The name is used later for plotting
purposes.

Having done this, a copy of this solution for the previous timestep,
\pyth{u_h_n}, can be created quite easily.

\renewcommand{\pweavecaption}{Copying a discrete function}
\renewcommand{\pweavelabel}{lst:forch-u_h_n}
```python, label = 'forch-u_h_n'
u_h_n = u_h.copy(name="previous")
```

There remains the question of what can we do with functions. Let us
show an example of computing the $L^2$ norm of the initial function.
We do this using \pyth{integrate} as follows.

\renewcommand{\pweavecaption}{Integrating the initial data}
\renewcommand{\pweavelabel}{lst:forch-integrate}
```python, label = 'forch-integrate'
from dune.fem.function import integrate
from ufl import sqrt
norm = sqrt( integrate(grid, initial, 5)[0] )
print(norm)
```

We can also plot discrete functions fairly easily. The two main ways to do
this in Fempy are either a quick plot in \pyth{matplotlib}
(see \cite{Matplotlib}), or writing to a
VTK file for use in Paraview (see \cite{Paraview}), as follows.

\renewcommand{\pweavecaption}{Plotting a function using two different
methods}
\renewcommand{\pweavelabel}{lst:forch-plot}
```python, label = 'forch-plot', fig=True, caption="The matplotlib plot of the initial function", width="0.475\\textwidth"
from dune.fem.plotting import plotPointData as plot
plot(initial, grid=grid)
grid.writeVTK('initial', pointdata={'initial': initial})
```

Note that \pyth{initial} here calls the UFL expression directly,
although calling functions is equally possible.

\subsection{Schemes} \label{sec:schemes}

In \dune[Fempy], we define schemes as the object containing the
bilinear form of the PDE, its boundary conditions and the method used
to approximate the inverse e.g. the iterative linear solver to use.
Specifically, for an operator $L: V_h \to V_h^{*}$, schemes have two
main functions.
\begin{enumerate}
\item Apply the operator. That is to calculate $w_h = L[v_h]$ given some $v_h \in V_h$.
\item Solve the PDE. That is to compute the solution $u_h$ to $L[u_h] = v_h$ given some $v_h \in
V_h^{*}$, by using a solve method. By default $v_h = 0$.
\end{enumerate}

\textbf{Remark.} In the case where only the operator application is
required/possible (e.g. when $L:V \to W \neq V$ , an \pyth{operator} object can be constructed
instead which comes without a solve method.

Recall the parabolic equation \eqref{eqn:forch-roche} which we will focus
on in the following. To begin with, it is
necessary to define the variables that are used in the equation.

\renewcommand{\pweavecaption}{Setting up UFL variables to be used}
\renewcommand{\pweavelabel}{lst:forch-variables}
```python, label = 'forch-variables'
from ufl import TestFunction, TrialFunction
from dune.ufl import NamedConstant
u = TrialFunction(space)
v = TestFunction(space)
dt = NamedConstant(space, "dt")    # time step
t  = NamedConstant(space, "t")     # current time
```

The trial function $u$ and the test function $v$ are defined on the
same \pyth{space} as before. Additionally $\Delta t$ and $t$ are
defined as \pyth{NamedConstant}, which is simply a UFL \pyth{Constant}
variable that can be given a name so it can be more easily modified
later on by using a property with the given name.

\textbf{Remark.} We note that as of the time of writing, spaces are
always vector valued and that scalar test/trial functions do not work
by default (i.e. one must specify \pyth{u[0]} even if \pyth{u} is 1D).

Now for the equation (\ref{eqn:forch-roche}) itself, let us prescribe
the following value for $K$.
\begin{equation}
  K(\nabla u) = \frac{2}{1+\sqrt{1+4\nabla u}}.
\label{eqn:parameters}
\end{equation}

This results in an implementation of the following form.

\renewcommand{\pweavecaption}{Implementing the bilinear form}
\renewcommand{\pweavelabel}{lst:forch-eqn-impl}
```python, label = 'forch-eqn-impl'
from ufl import dx, grad, inner
abs_du = sqrt(inner(grad(u), grad(u)))
K = 2/(1 + sqrt(1 + 4*abs_du))
a = (inner((u - u_h_n)/dt, v) + inner(K*grad(u), grad(v)))*dx
```

For the exact solution we will use the following (which is consistent
with the initial data).
\begin{equation}
  u(x,t) = e^{-2t}\left(\frac{1}{2}(x_0^2 + x_1^2) -
  \frac{1}{3}(x_0^3 - x_1^3)\right) + 1
\label{eqn:exact}
\end{equation}

We can use \pyth{initial} to define this using some algebra, and we
write a lambda function that takes \pyth{t} as argument.
\renewcommand{\pweavecaption}{The exact solution}
\renewcommand{\pweavelabel}{lst:forch-exact}
```python, label = 'forch-exact'
from ufl import as_vector, exp
exact = lambda t: as_vector([exp(-2*t)*(initial - 1) + 1])
```

To set the right hand side of the equation, i.e. $f$, we put the
exact solution into the left hand side of the PDE using \pyth{replace} as follows.

\renewcommand{\pweavecaption}{Setting up the right hand side}
\renewcommand{\pweavelabel}{lst:forch-rhs}
```python, label = 'forch-rhs'
from ufl import replace
b = replace(a, {u: exact(t)})
```

Having defined the bilinear form and right hand side, we can now set
up a scheme object which we can use to solve the PDE.

\renewcommand{\pweavecaption}{Creating an $H^{1}$ scheme}
\renewcommand{\pweavelabel}{lst:forch-scheme}
```python, label = 'forch-scheme'
scheme = create.scheme("galerkin", a == b, solver='cg')
```

The above function creates a simple Galerkin method for $H^1$
conforming elements, with the space and equation passed in. As before
there exist other such premade \dune schemes for different problems
(see \ref{sec:scheme-list})

Additionally the solver can be specified, so for this instance we use
\pyth{'cg'} for a conjugate gradient method, since the PDE is symmetric.

Lastly we note that it is possible to explictly define a model object
to hold the method, and we investigate the different ways of doing
this in section \ref{sec:header}.

\subsection{Solving} \label{sec:solving}

The last natural part of a FEM is the solving, which includes
time loops, mesh refinements, data output and plotting, and so on.
Let us begin by setting up the timestep, $\Delta t = 0.05$, by
assigning it in the model (using the name given to the coefficient
previously).

\renewcommand{\pweavecaption}{Setting up time variables before the
loop}
\renewcommand{\pweavelabel}{lst:forch-pre-solve}
```python, label = 'forch-pre-solve'
scheme.model.dt = 0.05
```

Next we write the following method for solving the problem over the
time range. Since the problem is time-dependent, we
solve over a for loop with $t_0 = 0, t_N = 1$, using \pyth{u_h_n} for
the old solution and \pyth{u_h} for the new one.

\renewcommand{\pweavecaption}{Evolve method for solving in time}
\renewcommand{\pweavelabel}{lst:forch-evolve}
```python, label='forch-evolve'
def evolve(scheme, u_h, u_h_n):
    time = 0
    endTime = 1.0
    while time < (endTime + 1e-6):
        scheme.model.t = time
        u_h_n.assign(u_h)
        scheme.solve(target=u_h)
        time += scheme.model.dt
```

Lastly we want to have a way of computing the error. Say for
instance we want to look at the $L^2$ and $H^1$ errors for our computed solution
assuming an exact solution $u$ is known at the final time of the
simulation.

\begin{equation}
 L^2\text{ error} = \int_{\Omega} | u - u_h |^2 \diff x, \qquad
 H^1\text{ error} = \int_{\Omega} | \nabla(u - u_h) |^2 \diff x.
\label{eqn:error}
\end{equation}

This can be achieved with the following code.

\renewcommand{\pweavecaption}{Writing expressions for the error
computed at the final time}
\renewcommand{\pweavelabel}{lst:forch-error}
```python, label = 'error'
exact_end = exact(1)
l2error_fn = inner(u_h - exact_end, u_h - exact_end)
h1error_fn = inner(grad(u_h - exact_end), grad(u_h - exact_end))
```

First of all we define the exact solution at the end time $T=1$,
\pyth{exact_end}. Then we simply write expressions in UFL to calculate
the $L^2$ and $H^1$ errors. We note that this works even though
\pyth{u_h} is a discrete function and not a UFL term itself,
since the expression is extracted from it automatically.

We also want to compute the estimated order of convergence (EOC), to test our
method.

\begin{equation*}
  EOC = \frac{\log(e_{new}/e_{old})}{\log(h_{new}/h_{old})}.
\label{eqn:eoc}
\end{equation*}

This is calculated by refining the grid and comparing the errors
($e_{old}$ and $e_{new}$) to the grid sizes ($h_{old}$ and
$h_{new}$), where the errors are computed using the error function
\pyth{l2error_fn} from \ref{lst:forch-error}. In particular for a grid size
that is being halved at each step, we do the following after each
solve step.

\renewcommand{\pweavecaption}{Calculating the EOCs}
\renewcommand{\pweavelabel}{lst:eoc}
\begin{pweavecode}
error_old = error                               # set the previous error
error = sqrt(integrate(grid, l2error_fn, 5)[0]) # integrate and sqrt
eoc = log(error/error_old)/log(0.5)             # do the EOC calculation
grid.hierarchicalGrid.globalRefine(1)           # refine the grid once
\end{pweavecode}

Combining these concepts into one solve method in Fempy, we have the
following program.

\renewcommand{\pweavecaption}{Solving the Forchheimer equation in
time and refining the grid}
\renewcommand{\pweavelabel}{lst:forch-main}
```python, label='forch-main', fig=True, caption='Plot of solutions at each level of refinement', width='0.32\\textwidth'
from math import log
error = 0
for eocLoop in range(3):
    print('# step:', eocLoop, ', size:', grid.size(0))
    u_h.interpolate(initial)
    evolve(scheme, u_h, u_h_n)
    error_old = error
    error = sqrt( integrate(grid, l2error_fn, 5)[0] )
    if eocLoop == 0:
        eoc = '-'
    else:
        eoc = log(error/error_old)/log(0.5)
    print('|u_h - u| =', error, ', eoc =', eoc)
    plot(u_h)
    grid.writeVTK('forchheimer', pointdata={'u': u_h, 'l2error':
                  l2error_fn, 'h1error': h1error_fn}, number=eocLoop)
    grid.hierarchicalGrid.globalRefine(1)
```

We compile a table of the errors and eocs for additional refinement
steps and a smaller timestep of $\Delta t = 0.001$ below.

\begin{center}
  \begin{tabular}{l | l | l | l | l}
    \hline
    Elements & $\|u - u_h\|_{L^2}$ & EOC & $|u - u_h|_{H^1}$ & EOC \\ \hline
    32 & 2.375e-05 & - & 9.238e-04 & - \\
    64 & 3.383e-06 & 2.812 & 2.240e-04 & 2.044 \\
    256 & 4.422e-07 & 2.936 & 5.575e-05 & 2.007 \\
    1024 & 5.596e-08 & 2.982 & 1.393e-05 & 2.001 \\
    4096 & 7.024e-09 & 2.994 & 3.482e-06 & 2.000
  \end{tabular}
\end{center}

\section{Alternate Solve Methods} \label{sec:solve}
```python, label="solve-methods", echo=False
# <markdowncell>
# ## Alternate Solve Methods
# Here we look at different ways of solving PDEs using external
# packages and python functionality.
# <codecell>
```

We carry on our explanation of different \dune[Fempy] features by
looking at the different methods of solving the PDE, which is
facilitated by the different storage backends for spaces.
We will continue to do so in the context of a worked examples
that demonstrate the practicality of these features.

We can specify alternate storage types as follows.

\renewcommand{\pweavecaption}{Accessing different storage types}
\renewcommand{\pweavelabel}{lst:storage}
\begin{pweavecode}
space = create.space('lagrange', grid, dimrange=1, order=2, storage='istl')
\end{pweavecode}

As before we construct the space, but now with the additional argument
that specifies the usage of \dune[Istl] (see \cite{Dune-Istl}) as a
linear algebra backend. Changing the
\pyth{storage} argument in the construction of the space makes
it possible to use more sophisticated solvers (either better
preconditioners or direct solvers). Other possibilites are shown in
\ref{tab:discrete-functions}.

In particular one thing that we can do with certain storage methods is
integrate methods from SciPy (\cite{SciPy}) into our code. This
allows for more complex ways of writing numerical methods without the
need to explicitly write it on the C++ side. Additionally we will show
that it is possible to store the degrees of freedom in such a way
that they can be treated as vectors from the NumPy package
(\cite{NumPy}) and an assembled system matrix can be stored in a SciPy
sparse matrix.

We present these methods once again via the Forchheimer example from \ref{sec:fem-in-fempy}.

In the following we implement a simple Newton solver: given an initial
guess $u^0$ (here taken to be zero) solve for $n\geq 0$,
\begin{align*}
   u^{n+1} = u^n - DS(u^n)(S(u^n)-g),
\end{align*}
where $g$ is a discrete function containing the Dirichlet boundary
conditions if they exist.

Usually this would be automatically taken care of in Fempy by
\pyth{scheme.solve}, however this time we will use the call operator on the
\pyth{scheme} to compute $S(u^n)$ as well as \pyth{scheme.assemble} to get a
copy of the system matrix in form of a SciPy sparse row matrix. Note
that this method is not available for all storage types.

\renewcommand{\pweavecaption}{Creating a class to hold a different
solve method}
\renewcommand{\pweavelabel}{lst:forch-newton}
```python, label='forch-newton', fig=True, caption='Plot of solution for python-side Newton scheme', width='0.5\\textwidth'
import numpy as np
from scipy.sparse.linalg import spsolve
class Scheme:
  def __init__(self, scheme):
      self.model = scheme.model

  def solve(self, target=None):
      # create a copy of target for the residual
      res = target.copy(name="residual")

      # create numpy vectors to store target and res
      sol_coeff = target.as_numpy
      res_coeff = res.as_numpy

      n = 0
      while True:
          scheme(target, res)
          absF = math.sqrt( np.dot(res_coeff,res_coeff) )
          if absF < 1e-10:
              break
          matrix = scheme.assemble(target).as_numpy
          sol_coeff -= spsolve(matrix, res_coeff)
          n += 1

scheme_cls = Scheme(scheme)

grid.hierarchicalGrid.globalRefine(-2)  # return grid to original state
u_h.interpolate(initial)                # reset u_h to original state
evolve(scheme_cls, u_h, u_h_n)
plot(u_h)
```

We can redo the above computation using a Newton-Krylov solver from
SciPy. We do this by constructing a class \pyth{Df} containing the
derivative of the operator. This would normally be done within DUNE,
but here we do it purely through python.

\renewcommand{\pweavecaption}{Implementing a Newton-Krylov solver with
SciPy}
\renewcommand{\pweavelabel}{lst:forch-df}
```python, label='forch-df', fig=True, caption='Plot of solution with Df operator', width='0.5\\textwidth'
from scipy.optimize import newton_krylov
from scipy.sparse.linalg import LinearOperator

def f(x_coeff):
    res = u_h.copy(name="residual")
    res_coeff = res.as_numpy
    x = space.numpyFunction(x_coeff, "tmp")
    scheme(x, res)
    return res_coeff

# class for the derivative DS of S
class Df(LinearOperator):
    def __init__(self, x_coeff):
        self.shape = (x_coeff.shape[0], x_coeff.shape[0])
        self.dtype = x_coeff.dtype
        # the following converts a given numpy array
        # into a discrete function over the given space
        x = space.numpyFunction(x_coeff, "tmp")
        # store the assembled matrix
        self.jac = scheme.assemble(x).as_numpy
    # reassemble the matrix DF(u) given a DoF vector for u
    def update(self, x_coeff, f):
        x = space.numpyFunction(x_coeff, "tmp")
        # Note: the following does produce a copy of the matrix
        # and each call here will reproduce the full matrix
        # structure - no reuse possible in this version
        self.jac = scheme.assemble(x).as_numpy
    # compute DS(u)^{-1}x for a given DoF vector x
    def _matvec(self, x_coeff):
        return spsolve(self.jac, x_coeff)

class Scheme2:
    def __init__(self, scheme):
        self.scheme = scheme
        self.model = scheme.model

    def solve(self, target=None):
        sol_coeff = target.as_numpy
        # call the newton krylov solver from scipy
        sol_coeff[:] = newton_krylov(f, sol_coeff,
                    verbose=0, f_tol=1e-8,
                    inner_M=Df(sol_coeff))

scheme2_cls = Scheme2(scheme)
u_h.interpolate(initial)
evolve(scheme2_cls, u_h, u_h_n)
plot(u_h)
```

We can also solvers from the PETSc package (see \cite{PETSc}) to solve
the problem. This can be done either through bindings available in
\dune[fem] or through the \pyth{petsc4py} package (\cite{PETSc4Py}).

\textbf{Remark.} Make sure that \dune has been configured using the
same version of PETSc used for \pyth{petsc4py}.

The first step is to change the storage in the space. This also
requires setting up the scheme and discrete functions again to use the
new storage structure.

We can directly use the PETSc solvers by invoking \pyth{solve} on the
scheme as before. Note that to do this we must change the storage type by
creating a new \pyth{space}. Then we have

\renewcommand{\pweavecaption}{Using petsc4py to solve using PETSc}
\renewcommand{\pweavelabel}{lst:forch-petsc}
```python, label='forch-petsc', fig=True, caption='Plot of solution using PETSc', width='0.5\\textwidth'
space = create.space("lagrange", grid, dimrange=1, order=2, storage='petsc')
scheme = create.scheme("galerkin", a == b, space=space,
                        parameters={"petsc.preconditioning.method":"sor"})
# first we will use the petsc solver available in the `dune-fem` package (using the sor preconditioner)
u_h = space.interpolate(initial, name='u_h')
u_h_n = u_h.copy(name="previous")
scheme.model.dt = 0.05
evolve(scheme, u_h, u_h_n)
plot(u_h)
```

Next we will implement the Newton loop in Python using \pyth{petsc4py}
to solve the linear systems.
We can access the PETSc vectors by calling \pyth{as_petsc} on the
discrete function. Note that this property will only be available if
the discrete function is an element of a space with storage
\pyth{'petsc'}. The method \pyth{assemble} on the scheme now returns
the sparse PETSc matrix and so we can directly use the KSP class
from \pyth{petsc4py}.

\renewcommand{\pweavecaption}{Using petsc4py and its Krylov solvers to
define a Newton scheme and solve}
\renewcommand{\pweavelabel}{lst:forch-petsc-ksp}
```python, label='forch-petsc-ksp', fig=True, caption='Plot of solution using PETSc and a Krylov method', width='0.5\\textwidth'
import petsc4py, sys
petsc4py.init(sys.argv)
from petsc4py import PETSc
ksp = PETSc.KSP()
ksp.create(PETSc.COMM_WORLD)
# use conjugate gradients method
ksp.setType("cg")
# and incomplete Cholesky
ksp.getPC().setType("icc")

class Scheme3:
  def __init__(self, scheme):
      self.model = scheme.model

  def solve(self, target=None):
      res = target.copy(name="residual")
      sol_coeff = target.as_petsc
      res_coeff = res.as_petsc

      n = 0
      while True:
          scheme(target, res)
          absF = math.sqrt( res_coeff.dot(res_coeff) )
          if absF < 1e-10:
              break
          matrix = scheme.assemble(target).as_petsc
          ksp.setOperators(matrix)
          ksp.setFromOptions()
          ksp.solve(res_coeff, res_coeff)
          sol_coeff -= res_coeff
          n += 1

u_h.interpolate(initial)
scheme3_cls = Scheme3(scheme)
evolve(scheme3_cls, u_h, u_h_n)
plot(u_h)
```

Finally we we will use PETSc's nonlinear solvers (the \pyth{snes}
classes) directly.

\renewcommand{\pweavecaption}{Using petsc4py and their nonlinear
solvers (SNES) directly}
\renewcommand{\pweavelabel}{lst:forch-petsc-snes}
```python, label='forch-petsc-snes', fig=True, caption='Plot of solution using SNES', width='0.5\\textwidth'
def f(snes, X, F):
    inDF = space.petscFunction(X)
    outDF = space.petscFunction(F)
    scheme(inDF,outDF)
def Df(snes, x, m, b):
    inDF = space.petscFunction(x)
    matrix = scheme.assemble(inDF).as_petsc
    m.createAIJ(matrix.size, csr=matrix.getValuesCSR())
    b.createAIJ(matrix.size, csr=matrix.getValuesCSR())
    return PETSc.Mat.Structure.SAME_NONZERO_PATTERN

class Scheme4:
    def __init__(self, scheme):
        self.scheme = scheme
        self.model = scheme.model

    def solve(self, target=None):
        res = target.copy(name="residual")
        sol_coeff = target.as_petsc
        res_coeff = res.as_petsc

        snes = PETSc.SNES().create()
        snes.setMonitor(lambda snes, i, r:print())
        snes.setFunction(f, res_coeff)
        # snes.setUseMF(True)
        matrix = self.scheme.assemble(target).as_petsc
        snes.setJacobian(Df, matrix, matrix)
        snes.getKSP().setType("cg")
        snes.setFromOptions()
        snes.solve(None, sol_coeff)

u_h.interpolate(initial)
scheme4_cls = Scheme4(scheme)
evolve(scheme4_cls, u_h, u_h_n)
plot(u_h)
```

\textbf{Remark.} The method \pyth{as_numpy}, \pyth{as_petsc} (returning the DoF vector either as
a \pyth{numpy} or a \pyth{petsc} vector) do not lead to a copy of the data and
the same is true for the \pyth{numpyFunction} and the \pyth{petscFunction}
methods on the space. In the \pyth{numpy} case we can use python's buffer
protocol to use the same underlying storage. In the case of
\pyth{petsc} the underlying \pyth{Vec} can be shared.

In the case of matrices the
situation is not yet as clear; \pyth{scheme.assemble} returns a copy of the
data in the \pyth{scipy} case while the \pyth{Mat} structure is shared between
C++ and python in the \pyth{petsc} case. But at the time of writing it
is not possible to pass in the \pyth{Mat} structure to the
\pyth{scheme.assemble} method from the outside. That is why it is necessary
to copy the data when using the \pyth{snes} nonlinear solver as seen
above.

\iffalse
One other thing we can do is assemble PDE systems on the python side
by using SciPy. For instance suppose we had a system of PDEs of the form

\[
\left( \begin{array}{cc}
  A & B \\
  B^T & C \end{array} \right)
  \left( \begin{array}{c}
  \textbf{u} \\
  \textbf{w} \end{array} \right)
  = \left( \begin{array}{c}
  \textbf{f} \\
  \textbf{g} \end{array} \right).
\]

If we have access to the schemes that represent $A, B$ and $C$, this
is easy to set up. First we can individually assemble the matrices from the schemes
and combine them into one matrix as follows.

\renewcommand{\pweavecaption}{Assembling matrices}
\renewcommand{\pweavelabel}{lst:assemble}
\begin{pweavecode}
from scipy.sparse import bmat
A  = scheme_a.assemble(uh).as_numpy
B  = scheme_b.assemble(uh).as_numpy
BT = B.transpose(copy=True)
C  = scheme_c.assemble(uh).as_numpy
system = bmat([[A, B], [BT, C]])
\end{pweavecode}

Suppose now schemes \pyth{scheme_a} and \pyth{scheme_c}
correspond to operators $L_a$ and $L_c$.
Then one can construct a RHS using the residuals from the schemes in a
similar way to below.

\renewcommand{\pweavecaption}{Assembling the right hand side}
\renewcommand{\pweavelabel}{lst:rhs}
\begin{pweavecode}
import numpy as np
wh = uh.copy()
f = uh.copy()
g = uh.copy()
uh_coeff = uh.as_numpy
wh_coeff = wh.as_numpy
f_coeff = f.as_numpy
g_coeff = g.as_numpy
scheme_a(uh, f)  # calculate L_a(uh) = f
f_coeff *= -1
scheme_c(uh, g)  # calculate L_c(uh) = g
g_coeff *= -1
rhs = np.concatenate((f_coeff, g_coeff))
sol = np.concatenate((uh_coeff, wh_coeff))
\end{pweavecode}

Finally the system can simply be solved using a CG solver.

\renewcommand{\pweavecaption}{Solving the system using SciPy}
\renewcommand{\pweavelabel}{lst:scipy-solve}
\begin{pweavecode}
from scipy.sparse.linalg import cg
sol, info = cg(system, rhs)
\end{pweavecode}
\fi

\section{Model Generation} \label{sec:header}

After having looked at the basics of the python
interface, let us now consider features more aimed at C++
integration and code extensibility.

We briefly alluded to a way of creating a model independent of a
scheme in section \ref{sec:schemes}, so let us expand upon this idea here.
We can separate the process into two steps as follows.

\renewcommand{\pweavecaption}{A simple elliptic model}
\renewcommand{\pweavelabel}{lst:elliptic}
\begin{pweavecode}
model = create.model('elliptic', grid, a == b)
scheme = create.scheme("galerkin", model)
\end{pweavecode}

where \pyth{a == b} refers to the UFL expression used to represent the
bilinear form, and \pyth{'elliptic'} refers to the elliptic operator
class in \dune. The purpose of this class is to have a set list of
virtualized methods that represent the standard
structure of what we consider is necessary for an
elliptic PDE model. This is then implemented in \dune[Fempy] by
translating the UFL input into a \dune class compatible format.

We note that this is a different approach to similar packages, which
in general do not create a virtual class and instead use the UFL form
directly. In fact such an approach is also available in \dune[Fempy],
using the \pyth{'integrands'} identifier. The choice between
\pyth{'elliptic'} and \pyth{'integrands'} models each lead to
separate advantages and disadvantages, which is what we would like to
discuss in this section.

\subsection{Elliptic Models}

First let us consider the default elliptic model. In mathematical
terms, consider the same general operator we defined previously.

\begin{equation}
  L[u] = -\nabla \cdot D(x, u) \nabla u + m(x, u, \nabla u).
  \tag{\ref{eqn:elliptic}}
\end{equation}

In variational form, after multiplying with a test function and
integration by parts (ignoring boundary terms for now), we arrive at

\[
  L[u] = \int_{\Omega}D(x, u) \nabla u \cdot \nabla v + m(x, u, \nabla u)
  v \diff x.
\]

Now the elliptic model class in Fempy has methods that represent
the above form in general terms. Suppose for instance we were to take
the case of $m(x, u, \nabla u) = u$ above. In the model class, this would be
defined under the method \cpp{source}.

\renewcommand{\pweavecaption}{A function in the elliptic model C++
class}
\renewcommand{\pweavelabel}{lst:elliptic-cpp}
\begin{pweavecode}
template< class Point >
void source ( const Point &x, const RangeType &u, const JacobianRangeType &du, RangeType &result ) const
{
  result[ 0 ] = u[ 0 ];
}
\end{pweavecode}

A similar method exists for $D(x, u)$, as well as linearized
versions for the purposes of nonlinear methods. Addtionally there are
methods for the associated Dirichlet or Neumann boundary conditions.
Together these form the elliptic model class which is the
one way of expressing bilinear forms in \dune[Fempy]. Generally this
class is then used to create a shared object file that is exported to
python using Pybind11 for use in python scripts and notebooks.

Another possibility provided for by the modular design of
\dune[python]  and the elliptic class structure is the creation of alternate
models. This approach involves the writing of additional C++
classes (one example would be a discontinuous Galerkin elliptic ) based on
the elliptic model class except with extra modifications that one
might want to make to the underlying structure.
Whilst this approach is more in-depth than simply editing
an elliptic header file, it allows one to change the functions
themselves beyond what the default elliptic model accepts.

An example of this approach is the \textit{nonvariational} model
for the \dune[femnv] module (see chapter \ref{sec:nvpdes}). This comes
from the desire to write bilinear forms that can accept a Hessian as
as argument as follows.

\begin{equation*}
  L[u] = \nabla \cdot D(x, u) \nabla u(x) + m(x, u, \nabla
  u, D^2 u).
\end{equation*}

Such a change would require different arguments to be made available
to the methods from the elliptic model. Suppose we wanted to
implement the nonvariational Poisson equation, i.e. taking $m = -\Delta u$
above. Then we would need the following method.

\renewcommand{\pweavecaption}{A nonvariational method}
\renewcommand{\pweavelabel}{lst:nvop}
\begin{pweavecode}
template< class Point >
void source ( const Point &x, const RangeType &u, const
JacobianRangeType &du, const HessianRangeType &d2u, RangeType &result ) const
{
  result[ 0 ] = d2u[ 0 ][ 0 ] + d2u[ 1 ][ 1 ];
}
\end{pweavecode}

Whilst this may not be immediately possible with the standard elliptic
model, it is possible to create a model \cpp{'nvdg'} that can
use such functions, which results in the ability to write functional
\dune[Fempy] code as follows.

\renewcommand{\pweavecaption}{The Fempy code for a nonvariational
model}
\renewcommand{\pweavelabel}{lst:fempy_nv}
\begin{pweavecode}
a = -(grad(grad(u[0])[0])[0] + grad(grad(u[0])[1])[1])*v[0]*dx
b = rhs(A, exact)
model = create.model("nvdg", grid, a == b)
\end{pweavecode}

Thus it becomes possible to write schemes that expect different
arguments from the operator.

\subsection{Integrands Models}

We note however that as mentioned before, there exists another way of
constructing operators, by using \pyth{'integrands'}. This method
bypasses the virtual methods used in the elliptic operator class and
creates methods purely using the UFL expressions given to it. This
again allows for expressions that are not by default allowed in the
default elliptic class, as shown below.

\renewcommand{\pweavecaption}{Usage of integrands operators for
skeleton terms}
\renewcommand{\pweavelabel}{lst:fempy_integrands}
\begin{pweavecode}
a = -(grad(grad(u[0])[0])[0] + grad(grad(u[0])[1])[1])*v[0]*dx
    + jump(A*grad(u[0]), n)*avg(v[0])*dS
b = rhs(A, exact)
scheme = create.model("integrands", space, a == b)
\end{pweavecode}

Here we take the nonvariational equation from before and add a term
defined only on the skeleton (the edges) of the mesh.

\subsection{C++ Models} \label{sec:cpp-models}

In addition to the automatic creation of a shared library object that
is done when \pyth{create} is called, it is
possible to generate a model class separately as a header file.
That is, it is possible to generate a C++ file (e.g. \cpp{'model.hh'}) that can be
used flexibly in both Fempy and regular C++ compatible \dune code. We can do this by
writing a pure UFL file and calling cmake on it.

Let us examine what this file looks like for the Forchheimer model.

\renewcommand{\pweavecaption}{UFL file used for C++ header file generation}
\renewcommand{\pweavelabel}{lst:header}
\begin{pweavecode}
space = Space(2, 1)
u = TrialFunction(space)
v = TestFunction(space)
x = SpatialCoordinate(space.cell())
dt = NamedConstant(triangle, "dt")    # time step
t  = NamedConstant(triangle, "t")     # current time
u_h_n = NamedCoefficient(space,"previous")

initial = 1/2*(x[0]**2 + x[1]**2) - 1/3*(x[0]**3 - x[1]**3) + 1
abs_du = sqrt(inner(grad(u), grad(u)))
K = 2/(1 + sqrt(1 + 4*abs_du))
a = (inner((u - u_h_n)/dt, v) + inner(K*grad(u), grad(v)))*dx
exact = as_vector( [exp(-2*t)*(initial - 1) + 1] )
b = replace(a, {u: exact})

F = a - b
\end{pweavecode}

Once the corresponding \cpp{forchheimer.hh} file has been generated,
it can then be edited manually in C++, and then used in place
of a UFL expression in Fempy. This choice of default shared library
generation or usable header files falls in line with
attempts we have made to improve extensibility of the code, since in
particular it allows for the user to write in more complex features in
C++ that do not necessarily have python bindings written for them.

Additionally we must ask the question of efficiency between using the
full \dune[Fempy] interface to run problems and simply using it to just generate a
model file to be used in C++. To look at this problem we constructed
an identical Forchheimer example in C++ which can be found in section
\ref{sec:forch-cpp}. We compare the runtime of the two solve-steps
below.

\begin{center}
  \captionof{table}{Runtimes for Forchheimer solve time}
  \begin{tabular}{l | l}
    \hline
     & Runtime (s) \\ \hline
    C++ & 78.3 \\
    Python & 83.0
  \end{tabular}
\end{center}

Thus we see there is not a sizable difference between the \dune[Fem] and
\dune[Fempy] versions.

\textbf{Remark.} We remark that both versions use preprocessing, which relatively
speaking is negligible for long-running simulations. We also note that
the most \textit{costly} aspect of pure python code are generally
callbacks, and in this example this amounts to just the solve call. An additional example
that taxes the two versions differently can be found in section
\ref{sec:mcf-comparison}.

\section{Adaptive Mesh Refinement} \label{sec:crystal}

We shall now consider the implementation of adaptive mesh refinement
in \dune[Fempy]. Adaptive mesh refinement is a technique that
allows for the targeted refinement of the computational domain in
specific areas where there is greater turbulence or activity, for greater
precision. In problems where uniform refinement of a mesh is not
required, this allows for more precision of the results at less
computational cost.

The method considered here uses so-called h-adaptivity that adds
additional mesh points to the grid at areas of small scale activity.
It does so based on a marking procedure that
evaluates the gradient of the solution at each element and determines
whether to refine the grid based on a level of tolerance.

In this section we present two examples which use adaptive grid
refinement in slightly different ways.

\input{laplace-adaptive.tex}

We shall now look at a model for crystallization on the surface of a
liquid.

\input{crystal.tex}
\section{Moving Meshes} \label{sec:mcf}

In this section we will consider an example where the grid itself
changes over time subject to PDEs. Specifically we refer to a
\textit{geometric evolution equation}, which describes the motion of a
hypersurface by prescribing its velocity geometrically. In
\dune[Fempy], it is possible to accomplish this through the following
process
\begin{enumerate}
\item Create an interpolated function that describes the initial
surface, i.e.
\renewcommand{\pweavecaption}{The initial function describing the
surface}
\renewcommand{\pweavelabel}{lst:mcf1}
\begin{pweavecode}
positions = space.interpolate(lambda x: some_function(x), name="position")
\end{pweavecode}
\item Create a surface using this function
\renewcommand{\pweavecaption}{The surface created from
\pyth{positions}}
\renewcommand{\pweavelabel}{lst:mcf2}
\begin{pweavecode}
surface = create.view("geometry", positions)
\end{pweavecode}
\item Create the scheme that describes the surface evolution and solve
it in the usual way.
\item Update the surface using the computed solution.
\renewcommand{\pweavecaption}{Reassigning the surface points using the
solution}
\renewcommand{\pweavelabel}{lst:mcf3}
\begin{pweavecode}
positions.dofVector.assign(solution.dofVector)
\end{pweavecode}
\end{enumerate}
With this process the surface (and by extension the mesh) can be
changed over time. We will now demonstrate this in a mean curvature flow
example.

\subsection{Mean Curvature Flow}

Mean curvature flow is a specific example of a geometric evolution
equation where the evolution is governed by the mean curvature $H$.
One real-life example of this is in how soap films change over time,
although it can also be applied to image processing (e.g.
\cite{Malladi}).
Assume we can define a reference surface $\Gamma_0$ such that
we can write the evolving surface $\Gamma(t)$ in the form
\begin{gather}
  \Gamma(t) = X(t,\Gamma_0)
\end{gather}
It is now possible to show that the vector valued function $X=X(t,x)$ with $x\in\Gamma_0$ satisfies:
\begin{gather}
  \frac{\partial}{\partial_t}X = - H(X)\nu(X)
\end{gather}
where $H$ is the mean curvature of $\Gamma_t$ and $\nu$ is its outward pointing normal.

We will solve this using a finite element approach based on the
following time discrete approximation from \cite[Eqn 4.16]{Charlie}
(with a $\theta$-scheme applied):
\begin{gather}
  \int_{\Gamma^n} \big( U^{n+1} - {\rm id}\big) \cdot \varphi +
    \tau \int_{\Gamma^n} \big(
    \theta\nabla_{\Gamma^n} U^{n+1} + (1-\theta) I \big)
    \colon\nabla_{\Gamma^n}\varphi
  =0~.
\end{gather}
Here $U^n$ parametrizes $\Gamma(t^{n+1})$ over
$\Gamma^n:=\Gamma(t^{n})$,
$I$ is the identity matrix, $\tau$ is the time step and
$\theta\in[0,1]$ is a discretization parameter.

\input{mcf.tex}

\section{Partitioned Grids} \label{sec:battery}

As another application of grid techniques, we look at a problem where
 we want to divide the grid into three regions. We do this using an
\pyth{'adaptive'} grid that allows for grid filters to be applied. We
note that another way of creating multi-domain grids in \dune is
described in \cite{Muthing}.

\input{battery.tex}


\section{Translating Python Code to C++} \label{sec:mcf-comparison}

One more thing we want to talk about is moving sections of python code
over to C++ for efficiency. A key aspect of the design of Fempy has
been about keeping the structure of the C++ code in the python code's
design, to the point where translating between the two is relatively painless. In
particular this allows for rapid prototyping of methods in python with
its relative ease of use, after which code can be ported to C++ for
efficiency if necessary in large-scale computation.

Here we will demonstrate this translation process, and additionally
provide comparisons for the difference in effiency timewise. We will
examine the function used for calculating the averaged radius of a
surface used in section \ref{sec:mcf}.

\renewcommand{\pweavecaption}{A pythonic function for calculating the
radius of a surface}
\renewcommand{\pweavelabel}{lst:calcR}
\begin{pweavecode}
def calcRadius(surface):
    # compute R = int_x |x| / int_x 1
    R   = 0
    vol = 0
    for e in surface.elements:
        rule = geometry.quadratureRule(e.type, 4)
        for p in rule:
            geo = e.geometry
            weight = geo.volume * p.weight
            R   += geo.toGlobal(p.position).two_norm * weight
            vol += weight
    return R/vol
\end{pweavecode}

As a relatively simple example, this code is not particularly slow in
python, however the existence of callbacks inside a looped statement
are not insignificant. Now let us look at a C++ translation of the above
code.

\renewcommand{\pweavecaption}{The C++ version of the calcRadius
function}
\renewcommand{\pweavelabel}{lst:calcR-cpp}
\begin{pweavecode}
#include <dune/geometry/quadraturerules.hh>

template< class Surface >
double calcRadius( const Surface &surface )
{
  double R = 0.;
  double vol = 0.;
  for( const auto &entity : elements( surface ) )
  {
    const auto& rule = Dune::QuadratureRules<double, 2>::rule(entity.type(), 4);
    for ( const auto &p : rule )
    {
      const auto geo = entity.geometry();
      const double weight = geo.volume() * p.weight();
      R   += geo.global(p.position()).two_norm() * weight;
      vol += weight;
    }
  }
  return R/vol;
}
\end{pweavecode}

We note that we take advantage of C++11 features such as \cpp{auto}
and range based for loops to keep a similar structure to the python
code.

Supposing we save the above as \cpp{radius.hh}, we can then call it
in a python script and use it like a regular function as follows.

\renewcommand{\pweavecaption}{Calling our C++ function using algorithm}
\renewcommand{\pweavelabel}{lst:calcR-algorithm}
\begin{pweavecode}
from dune.generator import algorithm
calcRadius = algorithm.load('calcRadius', 'radius.hh', surface)
\end{pweavecode}

Doing this, we can quite easily swap between the two versions and
compare the runtime of the solve method. We show these results in
figure \ref{fig:mcf-comparison}.

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth, height=8cm,
keepaspectratio]{figures/mcf-comparison.png}
\caption{Comparison of time taken between the two calcRadius methods}
\label{fig:mcf-comparison}
\end{figure}

What we see is that the C++ version is roughly 18\% faster. On a small
scale this is not a significant change, but it shows that it can be
worth the extra coding time for longer running simulations.

%</tag>

\bibliographystyle{abbrvnat}
\bibliography{dune-fempy}

\begin{appendix}

%<*append>

\chapter{Derivation of Forchheimer model} \label{sec:forch}
The origin of this equation stems from Darcy's law, an equation that
describes flow through porous media, and is applied regularly to
groundwater flow models.

\begin{equation}
  -\nabla p = \frac{\mu}{\kappa} v,
\label{eqn:darcy}
\end{equation}

where $p, v, \mu$ and $\kappa$ are the pressure, velocity, absolute
viscosity and permeability. For situations where the Reynolds number
is greater than \~10, inertia begins to have an effect on the system,
which is accounted for in the Darcy-Forchheimer equation. In its most
general form we have the following.

\begin{equation}
  -\nabla p = \sum^N_{i=0}a_i |v|^{\alpha_i}v,
\label{eqn:darcy-forch}
\end{equation}

where $a_i$ and $\alpha_i$ are obtained empirically. Through some
manipulations, we can simplify this to an equation for just the
pressure $\rho$.

\begin{equation}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f,
\label{eqn:forch}
\end{equation}

where the function $K: \mathbb{R}^{+} \to \mathbb{R}^{+}$ is dependent
on the $a_i$ and $\alpha_i$ above. Adding in boundary data and initial
values gives us the \textbf{boundary value problem}.

\begin{equation}
  \begin{array}{ll}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f & \mbox{in
  } \Omega \times [0, T], \\
  \rho(x, 0) = \rho^{0}(x) & \mbox{in } \Omega, \\
  K(|\nabla \rho|) \nabla \rho \cdot \textbf{n} + g(x) = 0 & \mbox{on }
  \Gamma \times [0, T],
  \end{array}
\label{eqn:forch-bvp}
\end{equation}

where $\rho^0$ and $g$ are initial and boundary data given. Thus
the \textbf{weak form} or variational formulation follows.

\begin{equation}
  (\rho_t, \varphi_h) + (K(|\nabla \rho|) \nabla \rho, \nabla \varphi_h) = - <
  g, \varphi_h> + (f, \varphi_h), \quad \varphi_h \in V_h,
\label{eqn:forch-weak}
\end{equation}

with $\rho(x, 0) = \rho^{0}(x)$. Finally it remains to discretize the
equation in time using a backward Euler method. Let the time domain $I
= [0,T]$ be divided into $N$ intervals $t_0 = 0 < t_1 < \dots < t_N = T$
such that $\Delta t = t_n - t_{n-1}$ and $\rho^{n} = \rho(x, t_n)$.
Then we have the time discretized PDE.

\begin{equation}
  \left(\frac{\rho^{n+1} - \rho^{n}}{\Delta t}, \varphi_h \right) +
  (K(|\nabla \rho^{n+1}|) \nabla \rho^{n+1},
  \nabla \varphi_h) = - < g, \varphi_h > + (f, \varphi_h), \quad
  \varphi_h \in V_h.
\label{eqn:forch-time}
\end{equation}

We note that in the form given in (\ref{eqn:forch-roche}), $g = 0$ and
we replace $\rho$ with $u$ for brevity.

\chapter{C++ Version of Forchheimer Example} \label{sec:forch-cpp}

Here we present the C++ version of the Forchheimer example from
section \ref{sec:fem-in-fempy} using \dune[FEM], that we compare to
the python version in section \ref{sec:cpp-models}.

\inputcpp{../../dune-fempy/forchheimer/main.cc}{}{lst:forch-cpp}

\chapter{List of Dune-Python modules} \label{sec:modules}

Here we list the different modules that are available to Dune-Python
and Fempy at the time of writing. We will divide them by component
into different sections that reflect the structure we have previously
introduced.

\section{Grids} \label{sec:grid-list}

Grids by default take the following form.

\renewcommand{\pweavecaption}{The default form for grid creation}
\renewcommand{\pweavelabel}{lst:default-grid}
\begin{pweavecode}
grid = create.grid('class-name', constructor, dimgrid=a, dimworld=b)
\end{pweavecode}

Where in particular we have the following arguments.

\begin{enumerate}
\item \pyth{'class-name'}: One of the strings from the table below.
\item \pyth{constructor}: Either a dgf \textit{dune grid format} file, a
gmesh file, or a preset object similar to what is demonstrated in
section \ref{sec:grids}.
\item \pyth{dimgrid} (optional): The dimension of the grid.
\item \pyth{dimworld} (optional): The dimension of the space the grid is in.
\end{enumerate}

The table below shows a list of possible classes to use to construct
grid objects.

\begin{center}
  \captionof{table}{Grids}
  \begin{tabular}{l | l | l}
    \hline
    Class & Module & Description \\ \hline \hline
    \input{tables/features_grid}
  \end{tabular}
\end{center}

Grids can also be constructed in the grid view format.

\begin{center}
  \captionof{table}{Gridviews}
  \begin{tabular}{l | l | l}
    \hline
    Class & Module & Description \\ \hline \hline
    \input{tables/features_view}
  \end{tabular}
\end{center}

\section{Spaces} \label{sec:space-list}

Now we move on to spaces. By default, they take the form

\renewcommand{\pweavecaption}{The default form for space creation}
\renewcommand{\pweavelabel}{lst:default-space}
\begin{pweavecode}
space = create.space('class-name', grid, dimgrid=a, order=b,
storage='type', field='double')
\end{pweavecode}

where we have the following arguments.

\begin{enumerate}
\item \pyth{'class-name'}: A string from the table below.
\item \pyth{grid}: A grid object from above.
\item \pyth{dimgrid} (optional): The dimension of the grid (deduced
from the grid by default).
\item \pyth{order} (optional): The polynomial order of the basis
functions.
\item \pyth{storage} (optional): \pyth{'fem'} by default. Specifies
the storage used for discrete functions (as shown in
\item \pyth{field} (optional): The field of the range space
(\pyth{'double'} or \pyth{'complex'}).
\ref{tab:discrete-functions}).
\end{enumerate}

\begin{center}
  \captionof{table}{Spaces}
  \begin{tabular}{l | l | l | l}
    \hline
    Class & Module & Description & kwargs \\ \hline \hline
    \input{tables/features_space}
  \end{tabular}
\end{center}

\section{Function}

Functions can be constructed in a variety of ways, though the explicit
way to make a grid function is

\renewcommand{\pweavecaption}{The default form for function creation}
\renewcommand{\pweavelabel}{lst:default-function}
\begin{pweavecode}
create.function('class-name', grid, 'function-name', order,
constructor)
\end{pweavecode}

with the following arguments.

\begin{enumerate}
\item \pyth{'class-name'}: A string from the table below.
\item \pyth{grid}: A grid object from \ref{sec:grid-list}.
\item \pyth{'function-name'}: A string for the name of the created
function.
\item \pyth{order}: The order of the function.
\item \pyth{constructor}: An object described in the table below used
to construct the function.
\end{enumerate}

For the below table we list the available constructors as they
describe each functions purpose.

\begin{center}
  \captionof{table}{Grid Functions}
  \begin{tabular}{l | l | l | l}
    \hline
    Class & Module & Constructor & kwargs \\ \hline \hline
    \input{tables/features_function}
  \end{tabular}
\end{center}

Discrete functions are typically made using the
\pyth{space.interpolate()} syntax, using the storage type for the
space by default. The following possibilities are available.

\begin{minipage}{\linewidth}
  \centering
  \captionof{table}{Discrete Functions}
  \label{tab:discrete-functions}
  \begin{tabular}{l | l | l}
    \hline
    Class & Module & Description \\ \hline \hline
    \input{tables/features_discretefunction}
  \end{tabular}
\end{minipage}

\section{Schemes} \label{sec:scheme-list}

As discussed in section \ref{sec:schemes}, schemes can be constructed
directly with a UFL form and contain the method for solving the PDE.
Addtionally as shown in section \ref{sec:header}, it is also possible to create
models and operators that store the operator separately. We review
this below.

\renewcommand{\pweavecaption}{The default form for scheme creation}
\renewcommand{\pweavelabel}{lst:default-scheme}
\begin{pweavecode}
scheme = create.scheme('class-name', equation, space, parameters=dict,
solver='solver-name')
\end{pweavecode}

\begin{enumerate}
\item \pyth{'class name'}: A string from the table below.
\item \pyth{space}: A space object from \ref{sec:space-list}. (This is
optional if the trial/test UFL functions are initialized with a
\dune[Fempy] discrete function space, as in code listing
\ref{lst:forch-variables}.)
\item \pyth{equation}: A UFL equation (\pyth{a == b}), or a model
object from \ref{tab:models}.
\item \pyth{parameters} (optional): A dictionary of \dune parameters that can be used
to specify things like the solver behaviour, e.g.
\pyth|{'fem.solver.newton.tolerance': 1e-3}|
\item \pyth{solver} (optional): \pyth{'fem'} by default. Used to
specify the solver used, from \ref{tab:solvers}.
\end{enumerate}

\begin{minipage}{\linewidth}
  \centering
  \captionof{table}{Schemes}
  \label{tab:schemes}
  \begin{tabular}{l | l | l | l}
    \hline
    Class & Module & Description & kwargs \\ \hline \hline
    \input{tables/features_scheme}
  \end{tabular}
\end{minipage}

\textbf{Remark.} We note that preconditioning is available via
parameters that can be set independently of the scheme. Available
options for methods include: \pyth{none, ssor, sor, ilu-0, ilu-n, gauss-seidel,
jacobi} and {amg-ilu-0}. They are set using the following syntax.

\renewcommand{\pweavecaption}{How preconditioning is set via
parameters}
\renewcommand{\pweavelabel}{lst:preconditioning}
\begin{pweavecode}
from dune.fem import parameter
parameter.append({"istl.preconditioning.method": "ilu",
                  "istl.preconditioning.iterations": 1,
                  "istl.preconditioning.relaxation": 1.2})
\end{pweavecode}

Now we consider the models that can be constructed independently of
the scheme.

\begin{minipage}{\linewidth}
  \centering
  \captionof{table}{Models}
  \label{tab:models}
  \begin{tabular}{l | l | l}
    \hline
    Class & Module & Description \\ \hline \hline
    \input{tables/features_model}
  \end{tabular}
\end{minipage}

Finally we look at operators that can be constructed and applied
without needing to assemble a scheme object.

\begin{center}
  \captionof{table}{Operators}
  \begin{tabular}{l | l | l}
    \hline
    Class & Module & Description\\ \hline \hline
    \input{tables/features_operator}
  \end{tabular}
\end{center}

\section{Solving}

Finally we list the possible solving methods available that can be
selected during scheme creation above.

\begin{minipage}{\linewidth}
  \centering
  \captionof{table}{Solvers}
  \label{tab:solvers}
  \begin{tabular}{l | l}
    \hline
    Class & Description\\ \hline \hline
    \input{tables/features_solver}
  \end{tabular}
\end{minipage}

%</append>

\end{appendix}

\end{document}
