\documentclass{ansarticle}

\usepackage{anslistings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{a4wide}
\usepackage{comment}
\usepackage{minted}

\definecolor{hrefcolor}{rgb}{0.0,0.0,0.8}
\newcommand{\linkcolor}{hrefcolor}
\hypersetup{pdfstartview=FitR}
\hypersetup{pdftitle={The DUNE-Fempy Module},
            pdfauthor={L. Connellan, A. Dedner, M. Nolte},
            breaklinks=true,
            linkbordercolor=\linkcolor,
            urlbordercolor=\linkcolor,
            citebordercolor=\linkcolor,
            runbordercolor=\linkcolor,
            menubordercolor=\linkcolor,
            filebordercolor=\linkcolor,
            runcolor=\linkcolor
            baseurl={https://gitlab.dune-project.org/extensions/dune-alugrid}
}
% make links underlined in acrobat reader
\hypersetup{pdfborderstyle={/S/U/W 1}}

\newcommand{\dune}[1][]{\textsc{Dune}\ifx&#1&\else\textsc{-{#1}}\fi\xspace}
\newcommand{\alugrid}{\textsc{ALUGrid}\xspace}
\newcommand{\ug}{\textsc{UG}\xspace}
\newcommand{\sionlib}{\textsc{SIONlib}\xspace}
\newcommand{\alberta}{\textsc{ALBERTA}\xspace}
\newcommand{\yaspgrid}{\textsc{YaspGrid}\xspace}

\newcommand{\matplotlib}{\pyth{Matplotlib}\xspace}
\newcommand{\quadpy}{\pyth{Quadpy}\xspace}
\newcommand{\numpy}{\pyth{Numpy}\xspace}
\newcommand{\scipy}{\pyth{Scipy}\xspace}
\newcommand{\paraview}{Paraview\xspace}
\newcommand{\vtk}{VTK\xspace}
\newcommand{\cmake}{cmake\xspace}
\newcommand{\pybind}{Pybind11\xspace}
\newcommand{\code}[1]{\lstinline[basicstyle=\small\sffamily]{#1} }
\newcommand{\file}[1]{\code{#1}}

\newcommand{\Atodo}[1]{\todo[inline]{{\bf\color{green}Andreas:} #1}}
\newcommand{\Ltodo}[1]{\todo[inline]{{\bf\color{blue}Lloyd:} #1}}
\newcommand{\Mtodo}[1]{\todo[inline]{{\bf\color{green}Martin:} #1}}

\newcommand{\pweavecaption}{}
\newcommand{\pweavelabel}{}
\lstnewenvironment{pweavecode}[1][]{\lstset{escapechar=`,moredelim=[il][]{\#tex},style=pythonstyle, title={\codetitlestyle{Python code }},belowcaptionskip=\belowtitleskip, caption=\pweavecaption,label=\pweavelabel}}{}
\lstnewenvironment{pweaveout}[1][]{\lstset{style=gencodestyle, title={\codetitlestyle{Output}}, belowcaptionskip=\belowtitleskip}}{}

\begin{document}

\title{The \dune[Fempy] Module}
\author[1]{Lloyd Connellan}% \thanks{l.connellan@warwick.ac.uk}}
\author[2]{Andreas Dedner}% \thanks{a.s.dedner@warwick.ac.uk}}
\author[3]{Martin Nolte}%\thanks{nolte@mathematik.uni-freiburg.de}}
\affil[1]{University of Warwick, UK}
\affil[2]{University of Warwick, UK}
\affil[3]{University of Freiburg, Germany}
\runningtitle{The \dune[Fempy] Module}
\runningauthor{Connellan, Dedner, Nolte}

\providecommand{\keywords}[1]{\textbf{Keywords: } #1}

\date{November, 2017}

\maketitle

Remove the following from the final tex output - leave in now so that
ptangle works
```python, label = "intro"
import time
import numpy
import math
import dune.plotting
dune.plotting.block = False
```

\begin{abstract}
In this paper we present the new \dune[Fempy] module...

\noindent
\keywords{..., \dune}
\end{abstract}

\section{Introduction}

Bullet point list of things to mention here:

\begin{enumerate}
  \item Remark on the importance of FEMs and their varied uses.
  \item Existing FEM software packages, both c++ libraries and the
  trend towards python packages and where there is a niche for fempy.
  \item Corepy/Python and overview of the features it has introduced,
  such as creation of .cache for efficiency of repeat usage.
  \item Usage of more recent pybind11 and C++11 features compared to
  other packages.
\end{enumerate}


%<*tag>

\section{Finite Element Methods in Fempy}

When designing any software package, a natural challenge that arises
is trying to make the user interface as simple and easy to use as possible.
At the same time however, we also want to create an interface that retains
all the functionality we need.

In the context of finite element methods, this leads to the question
of what the minimal functional structure for a FEM looks like. To
understand this question best, let us first outline the general
form that a FEM takes mathematically.

To begin with, the original problem we typically want to apply a finite
element method to is a continuous ODE or PDE in some
infinite-dimensional space $V$. First let $\Omega \subset \mathbb{R}^d$ be
a polygonal domain for our problem. We then choose a
finite element space $V_h = \{ v_h : \Omega \to \mathbb{R}^r \}
\subset V$, where dim $V_h = N$. This involves choosing a basis for
$V_h$, which can vary depending on the problem, but typically involves
piecewise polynomial functions.

Next the variational (or weak) form of the equation is defined. For
the purpose of illustration, let us assume to start with we have a
parabolic PDE of the following general form.

\begin{equation*}
  \begin{array}{ll}
  \partial_t u + L[u] = f & \mbox{in } \Omega \times [0, T], \\
  u(x, 0) = u^0(x) & \mbox{in } \Omega, \\
  D \cdot \textbf{n} = \phi(x) & \mbox{on } \Gamma \times [0, T],
  \end{array}
\label{eqn:parabolic}
\end{equation*}

where the elliptic operator L is defined as

\begin{equation*}
  L[u] := -\nabla \cdot D(x, u, \nabla u) \nabla u(x) + m(x, u, \nabla u).
\label{eqn:elliptic}
\end{equation*}

and $u^0$ and $\phi$ are the initial and boundary conditions. The
variational form is then obtained in the usual way via integration by
parts and discretization in time. This leads to methods that take the following form.

\begin{equation}
  \int_{\Omega} u^{n+1} + \Delta t L_I[u^{n+1}] dx = \int_{\Omega} u^n + \Delta t L_E[u^n] dx.
\label{eqn:rothe}
\end{equation}

where $L_I$ and $L_E$ are the implicit and explicit parts of $L$,
defined as

\begin{gather}
  L_I[u] = D_1(x, u \nabla u) \cdot \nabla \varphi + m_1(x, u, \nabla u) \varphi dx, \quad \\
  L_E[u] = D_2(x, u \nabla u) \cdot \nabla \varphi + (m_2(x, u, \nabla u) + f^n + \phi^n) \varphi dx,
\label{eqn:im-ex}
\end{gather}

and $D_1 -D_2 = \Delta t D$, $m_1 - m_2 = m$. The last step is to
solve this system iteratively for $u^{n+1} \in V_h$. This also
involves potential variation in terms of the solver used and possible
nonlinearity of the problem.

%In the case where $D(u(x), x)$ and $m(u(x), x)$ are nonlinear,
%Newton's method is used to solve the system. Denoting the general PDE
%by the operator $L(u)$, that gives us the iteration

%\begin{equation}
%  L(u^n) = -DL(u^n, \delta^n)(u^{n+1} - u^n),
%\label{eqn:newton}
%\end{equation}

%where $DL$ is the Jacobian of $L$.

With this general form in mind, in \dune[Fempy] we have designed the
structure to take as similar style as possible, in particular
considering the following breakdown of parts.

\begin{itemize}
  \item \ref{sec:grids} Grids. The computational domain the problem is set in.
  \item \ref{sec:spaces} Spaces. The finite element space and type of basis functions.
  \item \ref{sec:models} Operators. The weak form of the equation and its boundary conditions.
  \item \ref{sec:functions} Functions. Functions defined in the FEM space that store the
  solution and other variables.
  \item \ref{sec:schemes} Schemes. The method of solving the PDE.
\end{itemize}

We note that there exist even further simplifications that can be made
in terms of this choice of division, as well as possible simplifications to the
accompanying methods themselves. Ultimately as a FEM package aimed more at
extensibility and for researchers who are willing to to some degree of
programming, we have opted for more complexity in some cases, though
in general this is quite a nuanced design decision that must be made on an
individual basis for each software package.

With that in mind, for the remainder of this section we shall
demonstrate in more detail how each of these function separately in the context of a
worked example, a FEM implementation of the Forchheimer equation \cite{Kieu}.

\subsection{Grids} \label{sec:grids}

The first aspect of FEMs that we consider is probably the most
fundamental aspect, that of the grid (or mesh). Indeed before looking at the
equations we want to solve themselves, we must look at the
computational domain and how we want to discretise it. Any numerical
software looking to emulate FEMs must be able to construct both simple
triangulated 2D domains and more complex surfaces and refinements.

For now we will look at a simple example. Let us suppose we
have a domain of the following form.
\begin{equation*}
  \Omega = \{ (x,y) \in \mathbb{R}^2 : 0 \leq x \leq 1, 0 \leq y \leq 1\}.
\label{eqn:domain}
\end{equation*}

In creating a computational grid for this domain, it will be necessary to specify
the following things.

\begin{enumerate}
  \item The shape (a square) and its vertices.
  \item The number of elements.
  \item The type of elements (squares? triangles?).
\end{enumerate}

With these points in mind, we implement the grid in the following way
in \dune[Fempy].

```python, label="grid", fig=True, caption="Plot of a 2D grid for two different levels of refinement", width="0.475\\textwidth"
from dune.fem.plotting import plotPointData as plot
import dune.create as create
grid = create.grid('ALUConform', dune.grid.cartesianDomain([0, 0], [1, 1], [4, 4]))
plot(grid)
grid2 = create.grid('ALUCube', dune.grid.cartesianDomain([0, 0], [1, 1], [8, 8]))
plot(grid2)
```

We note that the above grid creation code snippet comes with two
necessary arguments. The first which we will see throughout this
example is a keyword for the \dune class we wish to use. In this case
\pyth{ALUConform} corresponds to a triangular discretization, whilst
\pyth{ALUCube} corresponds to squares.

The second argument is an object describing a rectangular
domain by specifying two opposite corners $(0,0)$ and $(1,1)$, and the number
of elements in each direction $(4,4)$ or $(8,8)$. Grids in fempy can
additionally be constructed via gmsh files or \textit{dune grid format} (dgf)
files when more complexity is required.

We note here once more that from a design standpoint, assumptions
could potentially be made to cut down on the complexity needed even
further, in situations where the exact grid dimensions are not
necessary. For instance a basic square grid could simply be made with
\pyth{grid = square()}, at the cost of modifications being less
obvious to make. This is a concept we would like to explore more in
the future of this package.

\subsection{Spaces} \label{sec:spaces}

The next key part of a FEM after constructing the grid is defining the
kind of elements we want to use, and by extension their space. In
particular this is important because the order of elements used can
dictate the solvability and the efficiency of the method.

Let us look at a simple creation of a Lagrange space in \dune[Fempy].

```python, label = 'space'
space = create.space('lagrange', grid, dimrange=1, order=2, storage='istl')
```

We note once again the salient features of the above function.

\begin{itemize}
  \item \pyth{'lagrange'} indicates that we will use a space with
  Lagrange basis functions.
  \item \pyth{grid} passes in the grid we constructed previously.
  \item \pyth{dimrange=1} (optional) sets the dimension of the range space to 1.
  \item \pyth{order=2} (optional) sets the order of the finite
  elements to 2.
  \item \pyth{storage='istl'} (optional) sets the linear algebra
  backend. For instance \pyth{'eigen'} allows for compatibility with
  functions in the eigen software package.
\end{itemize}

Crucially, like before the first argument tells DUNE which class to
use for compilation. For instance this can be edited to use a discontinuous
Galerkin space with orthonormal basis functions instead by using
\pyth{'dgonb'}.

\subsection{Models} \label{sec:models}

Let us now consider how models could be implemented.
Specifically we refer to the weak form of a PDE and its boundary
conditions.

To see this applied to an example, let us consider a
nonlinear parabolic equation derived in \cite{Kieu}. The origin of
this equation stems from Darcy's law, an equation that describes flow
through porous media, and is applied regularly to groundwater flow
models.

\begin{equation}
  -\nabla p = \frac{\mu}{\kappa} v,
\label{eqn:darcy}
\end{equation}

where $p, v, \mu$ and $\kappa$ are the pressure, velocity, absolute
viscosity and permeability. For situations where the Reynolds number
is greater than ~10, inertia begins to have an effect on the system,
which is accounted for in the Darcy-Forchheimer equation. In its most
general form we have the following.

\begin{equation}
  -\nabla p = \sum^N_{i=0}a_i |v|^{\alpha_i}v,
\label{eqn:darcy-forch}
\end{equation}

where $a_i$ and $\alpha_i$ are obtained empirically. Through some
manipulations, we can simplify this to an equation for just the
pressure $\rho$.

\begin{equation}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f,
\label{eqn:forch}
\end{equation}

where the function $K: \mathbb{R}^{+} \to \mathbb{R}^{+}$ is dependent
on the $a_i$ and $\alpha_i$ above. Adding in boundary data and initial
values gives us the \textbf{boundary value problem}.

\begin{equation}
  \begin{array}{ll}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f & \mbox{in
  } \Omega \times [0, T], \\
  \rho(x, 0) = \rho^{0}(x) & \mbox{in } \Omega, \\
  K(|\nabla \rho|) \nabla \rho \cdot \textbf{n} + \phi(x) = 0 & \mbox{on }
  \Gamma \times [0, T],
  \end{array}
\label{eqn:forch-bvp}
\end{equation}

where $\rho^0$ and $\phi$ are initial and boundary data given. Thus
the \textbf{weak form} or variational formulation follows.

\begin{equation}
  (\rho_t, v_h) + (K(|\nabla \rho|) \nabla \rho, \nabla v_h) = - <
  \phi, v_h> + (f, v_h), \quad v_h \in V_h,
\label{eqn:forch-weak}
\end{equation}

with $\rho(x, 0) = \rho^{0}(x)$. Finally it remains to discretize the
equation in time using a backward Euler method. Let the time domain $I
= [0,T]$ be divided into $N$ intervals $t_0 = 0 < t_1 < \dots < t_N = T$
such that $\Delta t = t_n - t_{n-1}$ and $\rho^{n} = \rho(x, t_n)$.
Then we have the time discretized PDE.

\begin{equation}
  \left(\frac{\rho^{n+1} - \rho^{n}}{\Delta t}, v_h \right) +
  (K(|\nabla \rho^{n+1}|) \nabla \rho^{n+1},
  \nabla v_h) = - < \phi, v_h > + (f, v_h), \quad v_h \in V_h.
\label{eqn:forch-time}
\end{equation}

We note that this is of the form described in (\ref{eqn:elliptic}) (plus
boundary term).

Now let us implement this numerically. First let us prescribe the
following values for (\ref{eqn:forch-time}).
\begin{equation}
  K(x) = \frac{2}{1+\sqrt{1+4x}}, \qquad \phi = 0.
\label{eqn:parameters}
\end{equation}

We will take an exact solution of
\begin{equation}
  \rho(x,t) = e^{-2t}\left(\frac{1}{2}(x_0^2 + x_1^2) -
  \frac{1}{3}(x_0^3 - x_1^3)\right) + 1
\label{eqn:exact}
\end{equation}
which leads to initial data $\rho^0 = \frac{1}{2}(x_0^2 + x_1^2) -
  \frac{1}{3}(x_0^3 - x_1^3) + 1$.

Let us now see how this would be implemented in
\dune[Fempy]. \Ltodo{explain some of the reason UFL is used as a
package and its advantages, like automatic differentiation}
\dune[Fempy] uses Unified Form Language (UFL) \cite{UFL}
to define models, which accepts equations written in a human-readable
variational form. The UFL implementation of (\ref{eqn:forch-time}) is
given below.

```python, label = 'forch-model'
from ufl import TestFunction, TrialFunction, SpatialCoordinate, Coefficient, Constant, triangle
from ufl import as_vector, dx, grad, inner, replace, exp, sqrt, dot
from dune.ufl import Space
uflSpace = Space((grid.dimGrid, grid.dimWorld), 1)
rho = TrialFunction(uflSpace)
v = TestFunction(uflSpace)
x = SpatialCoordinate(uflSpace.cell())
dt = Constant(triangle)         # time step
t  = Constant(triangle)         # current time

initial = 1/2*(x[0]**2 + x[1]**2) - 1/3*(x[0]**3 - x[1]**3) + 1
initial_gf = create.function('ufl', grid, 'initial', 5, initial)
rho_h = space.interpolate(initial_gf, name='rho_h')
rho_h_n = rho_h.copy()

abs_drho = sqrt(inner(grad(rho), grad(rho)))
K = 2/(1 + sqrt(1 + 4*abs_drho))
a = (inner((rho - rho_h_n)/dt, v) + inner(K*grad(rho), grad(v)))*dx
exact = as_vector( [exp(-2*t)*(initial - 1) + 1] )
b = replace(a, {rho: exact})

model = create.model('elliptic', grid, a == b)
```

Let us explain some of the tools used to construct this equation.
\begin{itemize}
\item $\rho$ and $v$ are defined as the trial and test functions.
\item $\Delta t$ and $t$ are defined as \pyth{Constants} so that their values
can be set later on in the program.
\item The equation itself uses UFL expressions such as \pyth{sqrt, inner}
and \pyth{exp} to represent the mathematical expressions. This
is later translated into C++ code for \dune.
\item The initial data is assigned a function \pyth{initial_gf} using
function creation (explained in section \ref{sec:functions}). This is
used to give the solution function \pyth{rho_h} its initial value.
\item The pressure from the previous time step $\rho_n$ is set up as a
discrete function \pyth{rho_h_n} so that its value can be passed into the model
at each new time step.
\item Here the right hand side \pyth{b} is defined simply by
substituting the exact data into the original equation.
\end{itemize}

\subsection{Functions} \label{sec:functions}

As we saw in the model construction in section \ref{sec:models}, it is
sometimes necessary to have functions aside from the model themselves
that independently store the data for the initial solution and
previous time step.

Let us once again look at the code snippet from before.

\renewcommand{\pweavecaption}{Function construction in \dune[Fempy]}
\renewcommand{\pweavelabel}{lst:function}
\begin{pweavecode}
initial = 1/2*(x[0]**2 + x[1]**2) - 1/3*(x[0]**3 - x[1]**3) + 1

initial_gf = create.function('ufl', grid, 'initial', 5, initial)
rho_h = space.interpolate(initial_gf, name='rho_h')
rho_h_n = rho_h.copy()
\end{pweavecode}

For the initial grid function \pyth{initial_gf}, the construction uses
much the same form as the model does, taking a UFL expression and a
grid. We also note \pyth{'initial'} is a named identifier and \pyth{5}
refers to the order.

Having constructed a grid function, a discrete function
\pyth{rho_h} can be made from it easily via interpolating the
\pyth{space} previously created. \pyth{rho_h_n} is created as a copy.

In addition to this, functions that store the exact solution and
calculate the error will often be necessary to create. Say for
instance we want to look at the $L^2$ and $H^1$ errors for our computed solution.

\begin{equation}
 L^2\text{ error} = \int_{\Omega} | u - u_h |^2 dx, \qquad
 H^1\text{ error} = \int_{\Omega} | \nabla(u - u_h) |^2 dx.
\label{eqn:error}
\end{equation}

This can be achieved with the following code.

```python, label = 'error'
exact_end = as_vector( [exp(-2)*(initial - 1) + 1] )
l2error_gf = create.function('ufl', grid, 'error', 5, dot(rho_h-exact_end, rho_h-exact_end))
h1error_gf = create.function('ufl', grid, 'error', 5, \
                            inner(grad(rho_h-exact_end), grad(rho_h-exact_end)))
```

First of all we define the exact solution at the end time $T=1$.
Then much like with \pyth{initial_gf}, we can simply write the
error functions via UFL by using \pyth{rho_h} and \pyth{exact_end}.
Note that this works even though \pyth{rho_h} is not a UFL expression
itself since the expression is extracted from it automatically.

\subsection{Schemes} \label{sec:schemes}

The last natural part of a FEM is solving it, which in particular
includes the assembly of the system matrices, and the choice of solver
used (which are usually exported by \dune). Secondary to this is providing some kind
of data output or plot from which we can analyze the results. To do
these things it is first of all necessary to define the scheme object.

```python, label = 'forch-scheme'
scheme = create.scheme("h1", space, model, solver='cg')
```

The above function creates a simple Galerkin method for $H^1$
conforming elements, with the space and model passed in. As before
there exist other such premade \dune schemes for different problems.
For instance \pyth{'dg'} is used for discontinous Galerkin methods,
\pyth{'stokes'} for Navier-Stokes problems, etc.

Additionally the solver can be specified, so for this instance we use
\pyth{'cg'} for a conjugate gradient method, since the PDE is symmetric.

Now let us solve the PDE. Since the problem is time-dependent, we
solve over a for loop with $t_0 = 0, t_N = 1$ and $\Delta t = 0.05$. We
also compute the estimated order of convergence (EOC), to test our
method.

\begin{equation*}
  EOC = \frac{\log(e_{new}/e_{old})}{\log(h_{new}/h_{old})}.
\label{eqn:eoc}
\end{equation*}

This is calculated by refining the grid and comparing the errors
($e_{old}$ and $e_{new}$) to the grid sizes ($h_{old}$ and
$h_{new}$), where the errors are computed using the error function
\pyth{l2error_gf} from \ref{eqn:error}.

If desired, lines can be added to plot the data visually. The two main ways to do
this in Fempy are either a quick plot in \pyth{matplotlib}, or writing to a
VTK file for use in Paraview, both of which are included below. In
Fempy we have the following code.

```python, label="forch-main", fig=True, caption="Plot of solutions at each level of refinement", width="0.32\\textwidth"
from math import log
timeStep = 0.05
model.setConstant(dt, timeStep)
error = 0

for eocLoop in range(1):
    print('# step:', eocLoop, ', size:', grid.size(0))
    time = 0.0
    endTime = 1.0
    rho_h.interpolate(initial_gf)
    while time < (endTime + 1e-6):
        model.setConstant(t, time)
        rho_h_n.assign(rho_h)
        scheme.solve(target=rho_h)
        time += timeStep
    error_old = error
    error = sqrt(l2error_gf.integrate()[0])
    if eocLoop == 0:
        eoc = '-'
    else:
        eoc = log(error/error_old)/log(0.5)
    print('|rho_h - rho| =', error, ', eoc =', eoc)
    plot(rho_h)
    grid.writeVTK('forchheimer', pointdata=[rho_h, l2error_gf], number=eocLoop)
    grid.hierarchicalGrid.globalRefine(2)
```

We compile a table of the errors and eocs for additional refinement
steps and a smaller timestep of $\Delta t = 0.001$ below.

\begin{center}
  \begin{tabular}{l | l | l | l | l}
    \hline
    Elements & $\|u - u_h\|_{L^2}$ & EOC & $|u - u_h|_{H^1}$ & EOC \\ \hline
    32 & 2.846e-05 & - & 9.128e-04 & - \\
    128 & 3.526e-06 & 3.0128 & 2.051e-04 & 2.154 \\
    512 & 4.605e-07 & 2.937 & 5.122e-05 & 2.002 \\
    2048 & 5.884e-08 & 2.968 & 1.282e-05 & 1.998 \\
    8192 & 1.605e-08 & 1.874 & 3.210e-06 & 1.998
  \end{tabular}
\end{center}

\Ltodo{Add example 2, rerun for smaller timestep to fix last eoc}


%</tag>

\section{Code (placeholder)}

\inputpython{../../dune-fempy/demo/forchheimer.py}{}{lst:forch-file}

\bibliographystyle{abbrvnat}
\bibliography{dune-fempy}

\end{document}
