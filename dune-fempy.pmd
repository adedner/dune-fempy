\documentclass{ansarticle}

\usepackage{anslistings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{a4wide}
\usepackage{comment}

\definecolor{hrefcolor}{rgb}{0.0,0.0,0.8}
\newcommand{\linkcolor}{hrefcolor}
\hypersetup{pdfstartview=FitR}
\hypersetup{pdftitle={The DUNE-Fempy Module},
            pdfauthor={L. Connellan, A. Dedner, M. Nolte},
            breaklinks=true,
            linkbordercolor=\linkcolor,
            urlbordercolor=\linkcolor,
            citebordercolor=\linkcolor,
            runbordercolor=\linkcolor,
            menubordercolor=\linkcolor,
            filebordercolor=\linkcolor,
            runcolor=\linkcolor
            baseurl={https://gitlab.dune-project.org/extensions/dune-alugrid}
}
% make links underlined in acrobat reader
\hypersetup{pdfborderstyle={/S/U/W 1}}

\newcommand{\dune}[1][]{\textsc{Dune}\ifx&#1&\else\textsc{-{#1}}\fi\xspace}
\newcommand{\alugrid}{\textsc{ALUGrid}\xspace}
\newcommand{\ug}{\textsc{UG}\xspace}
\newcommand{\sionlib}{\textsc{SIONlib}\xspace}
\newcommand{\alberta}{\textsc{ALBERTA}\xspace}
\newcommand{\yaspgrid}{\textsc{YaspGrid}\xspace}

\newcommand{\matplotlib}{\pyth{Matplotlib}\xspace}
\newcommand{\quadpy}{\pyth{Quadpy}\xspace}
\newcommand{\numpy}{\pyth{Numpy}\xspace}
\newcommand{\scipy}{\pyth{Scipy}\xspace}
\newcommand{\paraview}{Paraview\xspace}
\newcommand{\vtk}{VTK\xspace}
\newcommand{\cmake}{cmake\xspace}
\newcommand{\pybind}{Pybind11\xspace}
\newcommand{\code}[1]{\lstinline[basicstyle=\small\sffamily]{#1} }
\newcommand{\file}[1]{\code{#1}}

\newcommand{\Atodo}[1]{\todo[inline]{{\bf\color{green}Andreas:} #1}}
\newcommand{\Ltodo}[1]{\todo[inline]{{\bf\color{blue}Lloyd:} #1}}
\newcommand{\Mtodo}[1]{\todo[inline]{{\bf\color{green}Martin:} #1}}

\newcommand{\pweavecaption}{}
\newcommand{\pweavelabel}{}
\lstnewenvironment{pweavecode}[1][]{\lstset{escapechar=`,moredelim=[il][]{\#tex},style=pythonstyle, title={\codetitlestyle{Python code }},belowcaptionskip=\belowtitleskip, caption=\pweavecaption,label=\pweavelabel}}{}
\lstnewenvironment{pweaveout}[1][]{\lstset{style=gencodestyle, title={\codetitlestyle{Output}}, belowcaptionskip=\belowtitleskip}}{}

\begin{document}

\title{The \dune[Fempy] Module}
\author[1]{Lloyd Connellan}% \thanks{l.connellan@warwick.ac.uk}}
\author[2]{Andreas Dedner}% \thanks{a.s.dedner@warwick.ac.uk}}
\author[3]{Martin Nolte}%\thanks{nolte@mathematik.uni-freiburg.de}}
\affil[1]{University of Warwick, UK}
\affil[2]{University of Warwick, UK}
\affil[3]{University of Freiburg, Germany}
\runningtitle{The \dune[Fempy] Module}
\runningauthor{Connellan, Dedner, Nolte}

\providecommand{\keywords}[1]{\textbf{Keywords: } #1}

\date{November, 2017}

\maketitle

Remove the following from the final tex output - leave in now so that
ptangle works
```python, label="Intro"
import time
import numpy
import math
import dune.plotting
dune.plotting.block = False
```

\begin{abstract}
In this paper we present the new \dune[Fempy] module...

\noindent
\keywords{..., \dune}
\end{abstract}

\section{Introduction}

\section{\dune[FEM]}

When designing any software package, a natural challenge that arises
is trying to make the user interface as simple and easy to use as possible.
At the same time however, we also want to create an interface that retains
all the functionality we need.

In the context of finite element methods, this leads to the question
of what the minimal functional structure for a FEM looks like. It is in trying to
answer this question that we have ended up with the current design
of \dune[Fempy], where in particular we have considered the division
of a FEM into its integral parts:

\begin{itemize}
  \item \ref{sec:grids} Grids. The computational domain the problem is set in.
  \item \ref{sec:spaces} Spaces. The finite element space and type of basis functions.
  \item \ref{sec:models} Models. The weak form of the equation and its boundary conditions.
  \item \ref{sec:functions} Functions. Functions defined in the FEM space that store the
  solution and other variables.
  \item \ref{sec:schemes} Schemes. The method of solving the PDE.
\end{itemize}

In this section, we shall demonstrate how each of these function
separately in the context of a worked example, a FEM implementation
of the Forchheimer equation \cite{Kieu}.

\subsection{Grids} \label{sec:grids}

The first aspect of FEMs that we consider is probably the most
fundamental aspect, that of the grid (or mesh). Indeed before looking at the
equations we want to solve themselves, we must look at the
computational domain and how we want to discretise it. Any numerical
software looking to emulate FEMs must be able to construct both simple
triangulated 2D domains and more complex surfaces and refinements.

For now we will look at a simple example. Let us suppose we
have a domain of the following form.
\begin{equation*}
  \Omega = \{ (x,y) \in \mathbb{R}^2 : 0 \leq x \leq 1, 0 \leq y \leq 1\}.
\label{eqn:domain}
\end{equation*}

In creating a grid for this domain, it will be necessary to specify
the following things.

\begin{enumerate}
  \item The shape (a square) and its vertices.
  \item The number of elements.
  \item The type of elements (squares? triangles?).
\end{enumerate}

\Ltodo{Perhaps we should mention even simpler possibilities such as
grid = square() that take default parameters that are possible}

With these points in mind, we implement the grid in the following way
in \dune[Fempy].

\renewcommand{\pweavelabel}{lstCompilingGrid}
```python, label="grid", fig=True, caption="Plot of a 2D grid for two different levels of refinement", width="0.475\\textwidth"
from dune.fem.plotting import plotPointData as plot
import dune.create as create
grid1 = create.grid("ALUConform", dune.grid.cartesianDomain([0, 0], [1, 1], [4, 4]))
plot(grid1)
grid2 = create.grid("ALUCube", dune.grid.cartesianDomain([0, 0], [1, 1], [8, 8]))
plot(grid2)
```

We note that the above grid creation code snippet comes with two
necessary arguments. The first which we will see throughout this
example is a keyword for the \dune class we wish to use. In this case
\pyth{ALUConform} corresponds to a triangular discretization, whilst
\pyth{ALUCube} corresponds to squares.

The second argument is an object describing a rectangular
domain by specifying two opposite corners $(0,0)$ and $(1,1)$, and the number
of elements in each direction $(4,4)$ or $(8,8)$. Grids in fempy can
additionally be constructed via gmsh files or \textit{dune grid format} (dgf)
files when more complexity is required.

\subsection{Spaces} \label{sec:spaces}

The next key part of a FEM after constructing the grid is defining the
kind of elements we want to use, and by extension their space. In
particular this is important because the order of elements used can
dictate the solvability and the efficiency of the method.

Let us look at a simple creation of a Lagrange space in \dune[Fempy].

\renewcommand{\pweavecaption}{Space construction in \dune[Fempy]}
\renewcommand{\pweavelabel}{lst:space}
\begin{pweavecode}
space = create.space('lagrange', grid, dimrange=1, order=2,
storage='eigen')
\end{pweavecode}

We note once again the salient features of the above function.

\begin{itemize}
  \item \pyth{'lagrange'} indicates that we will use a space with
  Lagrange basis functions.
  \item \pyth{grid} passes in the grid we constructed previously.
  \item \pyth{dimrange=1} (optional) sets the dimension of the range space to 1.
  \item \pyth{order=2} (optional) sets the order of the finite
  elements to 2.
  \item \pyth{storage='eigen'} (optional) sets the linear algebra
  backend. This choice allows for compatibility with functions in the eigen
  software package.
\end{itemize}

Crucially, like before the first argument tells DUNE which class to
use for compilation. For instance this can be edited to use a discontinuous
Galerkin space with orthonormal basis functions instead by using
\pyth{'dgonb'}.

\subsection{Models} \label{sec:models}

Let us now consider how models could be implemented.
Specifically we refer to the weak form of a PDE and its boundary
conditions.

Generally speaking \dune allows for variational elliptic PDEs of the
following form.

\begin{equation}
  \int_{\Omega} D(u(x),x) \nabla u \cdot \nabla \varphi + m(u(x), x)
  \varphi dx = \int_{\Omega} f \varphi dx.
\label{eqn:elliptic}
\end{equation}

To see this applied to an example, let us consider a
nonlinear parabolic equation derived in \cite{Kieu}. The origin of
this equation stems from Darcy's law, an equation that describes flow
through porous media, and is applied regularly to groundwater flow
models.

\begin{equation}
  -\nabla p = \frac{\mu}{\kappa} v,
\label{eqn:darcy}
\end{equation}

where $p, v, \mu$ and $\kappa$ are the pressure, velocity, absolute
viscosity and permeability. For situations where the Reynolds number
is greater than ~10, inertia begins to have an effect on the system,
which is accounted for in the Darcy-Forchheimer equation. In its most
general form we have the following.

\begin{equation}
  -\nabla p = \sum^N_{i=0}a_i |v|^{\alpha_i}v,
\label{eqn:darcy-forch}
\end{equation}

where $a_i$ and $\alpha_i$ are obtained empirically. Through some
manipulations, we can simplify this to an equation for just the
pressure $\rho$.

\begin{equation}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f,
\label{eqn:forch}
\end{equation}

where the function $K: \mathbb{R}^{+} \to \mathbb{R}^{+}$ is dependent
on the $a_i$ and $\alpha_i$ above. Adding in boundary data and initial
values gives us the \textbf{boundary value problem}.

\begin{equation}
  \begin{array}{ll}
  \rho_t - \nabla \cdot (K(|\nabla \rho|) \nabla \rho) = f & \mbox{in
  } \Omega \times I, \\
  \rho(x, 0) = \rho^{0}(x) & \mbox{in } \Omega, \\
  K(|\nabla \rho|) \nabla \rho \cdot \nu + \phi = 0 & \mbox{on }
  \Gamma \times I,
  \end{array}
\label{eqn:forch-bvp}
\end{equation}

where $\rho^0$ and $\phi$ are initial and boundary data given. Thus
the \textbf{weak form} or variational formulation follows.

\begin{equation}
  (\rho_t, v_h) + (K(|\nabla \rho|) \nabla \rho, \nabla v_h) = - <
  \phi, v_h> + (f, v_h), \quad v_h \in V_h,
\label{eqn:forch-weak}
\end{equation}

with $\rho(x, 0) = \rho^{0}(x)$. Finally it remains to discretize the
equation in time using a backward Euler method. Let the time domain $I
= [0,T]$ be divided into $N$ intervals $t_0 = 0 < t_1 < \dots < t_N = T$
such that $\Delta t = t_n - t_{n-1}$ and $\rho^{n} = \rho(x, t_n)$.
Then we have the time discretized PDE.

\begin{equation}
  \left(\frac{\rho^{n+1} - \rho^{n}}{\Delta t}, v_h \right) +
  (K(|\nabla \rho^{n+1}|) \nabla \rho^{n+1},
  \nabla v_h) = - < \phi, v_h > + (f, v_h), \quad v_h \in V_h.
\label{eqn:forch-time}
\end{equation}

We note that this is of the form described in (\ref{eqn:elliptic}) (plus
boundary term).

\Ltodo{Move newton explanation somewhere}
Since $D(u(x), x)$ and $m(u(x), x)$ are nonlinear in this case,
Newton's method is used to solve the system. Denoting the general PDE
by the operator $L(u)$, that gives us the iteration

\begin{equation}
  L(u^n) = -DL(u^n, \delta^n)(u^{n+1} - u^n),
\label{eqn:newton}
\end{equation}

where $DL$ is the Jacobian of $L$.

Now let us implement this numerically. First let us prescribe the
following values for (\ref{eqn:forch-time}).
\begin{equation}
  K(x) = \frac{2}{1+\sqrt{1+4x}}, \qquad \phi = 0.
\label{eqn:parameters}
\end{equation}

We will take an exact solution of
\begin{equation}
  \rho(x,t) = e^{-2t}\left(\frac{1}{2}(x_0^2 + x_1^2) -
  \frac{1}{3}(x_0^3 - x_1^3)\right) + 1
\label{eqn:exact}
\end{equation}
which leads to initial data $\rho^0 = \frac{1}{2}(x_0^2 + x_1^2) -
  \frac{1}{3}(x_0^3 - x_1^3) + 1$.

Let us now see how this would be implemented in
\dune[Fempy]. \Ltodo{explain some of the reason UFL is used as a
package and its advantages} \dune[Fempy] uses Unified Form Language (UFL) \cite{UFL}
to define models, which accepts equations written in a human-readable
variational form. The UFL implementation of (\ref{eqn:forch-time}) is
given below.

\renewcommand{\pweavecaption}{Forchheimer model in UFL}
\renewcommand{\pweavelabel}{lst:forch-model}
\begin{pweavecode}
uflSpace = Space((grid.dimGrid, grid.dimWorld), 1)
rho = TrialFunction(uflSpace)
v = TestFunction(uflSpace)
x = SpatialCoordinate(uflSpace.cell())
rho_n = Coefficient(uflSpace)   # previous rho
dt = Constant(triangle)         # time step
t  = Constant(triangle)         # current time

abs_drho = sqrt(inner(grad(rho), grad(rho)))
K = 2/(1 + sqrt(1 + 4*abs_drho))
a = (inner((rho - rho_n)/dt, v) + inner(K*grad(rho), grad(v)))*dx
initial = 1/2*(x[0]*x[0] + x[1]*x[1]) - 1/3*(pow(x[0],3) - pow(x[1],3)) + 1
exact = as_vector( [exp(-2*t)*(initial - 1) + 1] )
b = replace(a, {rho: exact})

initial_gf = create.function("ufl", grid, "initial", 5, initial)
rho_h = space.interpolate(initial_gf, name="rho_h")
rho_h_n = rho_h.copy()

model = create.model("elliptic", grid, a == b, coefficients={rho_n: rho_h_n})
\end{pweavecode}

Let us explain some of the tools used to construct this equation.
\begin{itemize}
\item The pressure from the previous time step $\rho_n$ is defined as a
\pyth{Coefficient} so that its value can be passed into the model
at each new time step from \pyth{rho_h_n} (the function used to store
it).
\item Similarly $\Delta t$ and $t$ are \pyth{Constants} whose values
can be set later on in the program.
\item The equation itself uses UFL expressions such as \pyth{sqrt, inner}
and \pyth{exp} to represent the mathematical expressions. This
is later translated into C++ code for \dune.
\item Here $f$ is defined simply by substituting the exact data
into the original equation.
\item The initial data is assigned a function \pyth{initial_gf} using
function creation (explained in example \ref{lst:function}). This is
used to give the solution function \pyth{rho_h} its initial value.
\end{itemize}

\subsection{Functions} \label{sec:functions}

As we saw in the model construction in example \ref{lst:forch-model}, it is
sometimes necessary to have functions aside from the model themselves
that independently store the data for the initial solution and
previous time step.

Let us once again look at the code snippet from before.

\renewcommand{\pweavecaption}{Function construction in \dune[Fempy]}
\renewcommand{\pweavelabel}{lst:function}
\begin{pweavecode}
initial = 1/2*(x[0]*x[0] + x[1]*x[1]) - 1/3*(pow(x[0],3) - pow(x[1],3)) + 1

initial_gf = create.function('ufl', grid, 'initial', 5, initial)
rho_h = space.interpolate(initial_gf, name='rho_h')
rho_h_n = rho_h.copy()
\end{pweavecode}

For the initial grid function \pyth{initial_gf}, the construction uses
much the same form as the model does, taking a UFL expression and a
grid. We also note \pyth{'initial'} is a named identifier and \pyth{5}
refers to the order.

Having constructed a grid function, a discrete function
\pyth{rho_h} can be made from it easily via interpolating the
\pyth{space} previously created. \pyth{rho_h_n} is created as a copy.

In addition to this, functions that store the exact solution and
calculate the error will often be necessary to create. Say for
instance we want to look at the $L^2$ error for our computed solution.

\begin{equation*}
  \int_{\Omega} | u - u_h |^2 dx.
\label{eqn:l2error}
\end{equation*}

This can be achieved with the following code.

\renewcommand{\pweavecaption}{Functions for error analysis}
\renewcommand{\pweavelabel}{lst:error}
\begin{pweavecode}
exact_gf = create.function('ufl', grid, 'exact', 5, exact)
def l2error(en, x):
    val = uh.localFunction(en).evaluate(x) - exact_gf.localFunction(en).evaluate(x)
    return [ val[0]*val[0] ];
l2error_gf = create.function('local', grid, 'error', 5, l2error)
\end{pweavecode}

The \pyth{exact_gf} is created in the same way as before, but we see
another way can be specified with \pyth{'local'} and providing a
python function.

\Ltodo{Is there a convenience function written for
this?}

\subsection{Schemes} \label{sec:schemes}

The last natural part of a FEM is solving it and providing some kind
of data output or plot. To do this it is first of all necessary to
define the method of solving (or scheme)

\renewcommand{\pweavecaption}{Scheme construction}
\renewcommand{\pweavelabel}{lst:scheme}
\begin{pweavecode}
scheme = create.scheme("h1", space, model)
\end{pweavecode}

The above function simply creates an elliptic FEM scheme for $H^1$
conforming elements, with the space and model passed in.

\section{Code (placeholder)}

\renewcommand{\pweavecaption}{Forchheimer demo}
\renewcommand{\pweavelabel}{lst:forchheimer}
%```python, label="ForchheimerPlot", fig=True, caption="plot of solution", width="0.475\\textwidth"
\begin{pweavecode}
import dune.fem
from dune.fem.plotting import plotPointData as plot
import dune.create as create
from math import log
from ufl import TestFunction, TrialFunction, SpatialCoordinate, Coefficient, Constant, triangle
from ufl import as_vector, dx, grad, inner, replace, exp, sqrt
from dune.ufl import Space

dune.fem.parameter.append("../data/parameter")
grid = create.grid("ALUConform", dune.grid.cartesianDomain([0, 0], [1, 1], [4, 4]), dimgrid=2)
space = create.space("lagrange", grid, dimrange=1, order=2, storage='istl')

uflSpace = Space((grid.dimGrid, grid.dimWorld), 1)
u = TrialFunction(uflSpace)
v = TestFunction(uflSpace)
x = SpatialCoordinate(uflSpace.cell())
un = Coefficient(uflSpace)   # coefficient used in ufl for old uh
dt = Constant(triangle)      # set to time step size later on
t  = Constant(triangle)      # current time

abs_dphi = sqrt(inner(grad(u), grad(u)))
K = 2/(1 + sqrt(1 + 4*abs_dphi))
a = (inner((u - un)/dt, v) + inner(K*grad(u), grad(v)))*dx
initial = 0.5*(x[0]*x[0] + x[1]*x[1]) - 1/3*(pow(x[0], 3) - pow(x[1], 3)) + 1
exact = as_vector( [exp(-2*t)*(initial - 1) + 1] )
exact_end = as_vector( [exp(-2)*(initial - 1) + 1] )
b = replace(a, {u: exact})

initial_gf = create.function("ufl", grid, "initial", 5, initial)
exact_gf = create.function("ufl", grid, "exact", 5, exact_end)
uh = space.interpolate(initial_gf, name="uh")
uh_n = uh.copy()

def l2error(en, x):
    val = uh.localFunction(en).evaluate(x) - exact_gf.localFunction(en).evaluate(x)
    return [ val[0]*val[0] ];
l2error_gf = create.function("local", grid, "error", 5, l2error)

model = create.model("elliptic", grid, a == b, coefficients={un: uh_n})

scheme = create.scheme("h1", space, model)

timeStep = 0.05
model.setConstant(dt, timeStep)
time = 0.0
endTime = 1.0

error = 10
for eocLoop in range(3):
    print('# step:', eocLoop, ", size:", grid.size(0))
    time = 0.0
    while time < (endTime + 1e-6):
        model.setConstant(t, time)
        uh_n.assign(uh)
        scheme.solve(target=uh)
        time += timeStep
    error_old = error
    error = sqrt(l2error_gf.integrate()[0])
    if eocLoop == 0:
        eoc = 'n/a'
    else:
        eoc = log(error/error_old)/log(0.5)
    plot(uh)
    print("|uh - u| =", error, ", eoc =", eoc)
    #grid.writeVTK('forchheimer', pointdata=[uh, error], number=eocLoop)
    grid.hierarchicalGrid.globalRefine(1)
\end{pweavecode}
\bibliographystyle{abbrvnat}
\bibliography{dune-fempy}

\end{document}
