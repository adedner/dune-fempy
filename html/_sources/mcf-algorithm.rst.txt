
Mean Curvature Flow
===================

In this example we compute the mean curvature flow of a surface:

.. math::

   \begin{align}
      \frac{\partial}{\partial_t} x &= H(x)  && \text{for } x\in\Gamma(t)
   \end{align}

Assume we can define a reference surface :math:`\Gamma_0` such that we
can write the evolving surface :math:`\Gamma(t)` in the form

.. math::

   \begin{gather}
     \Gamma(t) = X(t,\Gamma_0)
   \end{gather}

It is now possible to show that the vector valued function
:math:`X=X(t,x)` with :math:`x\in\Gamma_0` satisfies:

.. math::

   \begin{gather}
     \frac{\partial}{\partial_t}X = - H(X)\nu(X)
   \end{gather}

where :math:`H` is the mean curvature of :math:`\Gamma_t` and
:math:`\nu` is its outward pointing normal.

We will solve this using a finite element approach based on the
following time discrete approximation:

.. math::

   \begin{gather}
     \int_{\Gamma^n} \big( U^{n+1} - {\rm id}\big) \cdot \varphi +
       \tau \int_{\Gamma^n} \big(
       \theta\nabla_{\Gamma^n} U^{n+1} + (1-\theta) I \big)
       \colon\nabla_{\Gamma^n}\varphi
     =0~.
   \end{gather}

Here :math:`U^n` parametrizes :math:`\Gamma(t^{n+1})` over
:math:`\Gamma^n:=\Gamma(t^{n})`, :math:`I` is the identity matrix,
:math:`\tau` is the time step and :math:`\theta\in[0,1]` is a
discretization parameter.

.. code:: ipython3

    import math, time
    import pickle
    
    from ufl import *
    import dune.ufl
    from dune.generator import algorithm
    import dune.geometry as geometry
    import dune.fem as fem
    from dune.fem.plotting import plotPointData as plot
    import matplotlib.pyplot as pyplot
    
    print("START",flush=True)
    
    # polynomial order of surface approximation
    order = 2
    
    # initial radius
    R0 = 2.
    
    # end time
    endTime = 0.1


.. parsed-literal::

    START


Main function for calculating the mean curvature flow of a given
surface. If first argument is ``True`` the radius of the computed
surface is computed using an algorithm implemented in C++ otherwise the
computation is done in Python.

Timings for a number of different grid refinements is dumped to disk

.. code:: ipython3

    from dune.fem.view import geometryGridView as geoGridView
    from dune.fem.space import lagrange as solutionSpace
    from dune.fem.scheme import galerkin as solutionScheme
    def calculate(use_cpp, gridView):
        # space on Gamma_0 to describe position of Gamma(t)
        space = solutionSpace(gridView, dimRange=gridView.dimWorld, order=order)
        u = TrialFunction(space)
        v = TestFunction(space)
        x = SpatialCoordinate(space.cell())
        positions = space.interpolate(x, name="position")
    
        # space for discrete solution on Gamma(t)
        surface = geoGridView(positions)
        space = solutionSpace(surface, dimRange=surface.dimWorld, order=order)
        solution  = space.interpolate(x, name="solution")
    
        # set up model using theta scheme
        theta = 0.5   # Crank-Nicholson
    
        I = Identity(3)
        dt = dune.ufl.Constant(0,"dt")
    
        a = (inner(u - x, v) + dt * inner(theta*grad(u)
            + (1 - theta)*I, grad(v))) * dx
    
        scheme = solutionScheme(a == 0, space, solver="cg")
    
        if use_cpp:
            radius = algorithm.load('calcRadius', 'radius.hh', surface)
            file_path = 'cpp_time.p'
        else:
            # compute an averaged radius of the surface
            def radius(surface):
                # compute R = int_x |x| / int_x 1
                R   = 0
                vol = 0
                for e in surface.elements:
                    rule = geometry.quadratureRule(e.type, 4)
                    for p in rule:
                        geo = e.geometry
                        weight = geo.volume * p.weight
                        R   += geo.toGlobal(p.position).two_norm * weight
                        vol += weight
                return R/vol
            file_path = 'python_time.p'
    
        scheme.model.dt = 0.02
    
        import numpy as np
        pyplot.figure()
        pyplot.gca().set_xlim([0, endTime])
        pyplot.gca().set_ylabel("error")
        pyplot.gca().set_xlabel("time")
    
        numberOfLoops = 3
        times = np.zeros(numberOfLoops)
        errors = np.zeros(numberOfLoops)
        totalIterations = np.zeros(numberOfLoops, np.dtype(np.uint32))
        gridSizes = np.zeros(numberOfLoops, np.dtype(np.uint32))
        for i in range(numberOfLoops):
            positions.interpolate(x * (R0/sqrt(dot(x,x))))
            solution.interpolate(x)
            t = 0.
            R = radius( surface )
            Rexact = math.sqrt(R0*R0 - 4.*t)
            iterations = 0
            start = time.time()
            while t < endTime:
                info = scheme.solve(target=solution)
                # move the surface
                positions.dofVector.assign(solution.dofVector)
                # store some information about the solution process
                iterations += int( info["linear_iterations"] )
                t          += scheme.model.dt
                R           = radius( surface )
                Rexact      = math.sqrt(R0*R0-4.*t)
            print("time used:", time.time() - start)
            times[i] = time.time() - start
            errors[i] = abs(R-Rexact)
            totalIterations[i] = iterations
            gridSizes[i] = gridView.size(2)
            if i < numberOfLoops - 1:
                gridView.hierarchicalGrid.globalRefine(1)
                scheme.model.dt /= 2
        eocs = np.log(errors[0:][:numberOfLoops-1] / errors[1:]) / math.log(math.sqrt(2))
        try:
            import pandas as pd
            keys = {'size': gridSizes, 'error': errors, "eoc": np.insert(eocs, 0, None), 'iterations': totalIterations}
            table = pd.DataFrame(keys, index=range(numberOfLoops),columns=['size', 'error', 'eoc', 'iterations'])
            print(table)
        except ImportError:
            print("pandas could not be used to show table with results")
            pass
        pickle.dump([gridSizes, times], open(file_path,'wb'))

Compute the mean curvature flow evolution of a spherical surface.
Compare computational time of a pure Python implementation and using a
C++ algorithm to compute the radius of the surface for verifying the
algorithm.

.. code:: ipython3

    # set up reference domain Gamma_0
    from dune.alugrid import aluConformGrid as leafGridView
    print("HALLO 1",flush=True)
    gridView = leafGridView("sphere.dgf", dimgrid=2, dimworld=3)
    print("HALLO 2",flush=True)
    calculate(True, gridView)
    print("HALLO 3",flush=True)
    gridView = leafGridView("sphere.dgf", dimgrid=2, dimworld=3)
    print("HALLO 4",flush=True)
    calculate(False, gridView)


.. parsed-literal::

    HALLO 1
    HALLO 2
    time used: 0.5624752044677734
    time used: 4.194444894790649
    time used: 19.218441009521484
       size     error       eoc  iterations
    0   318  0.001060       NaN          94
    1   854  0.000599  1.647357         390
    2  2065  0.000273  2.262345         895
    HALLO 3
    HALLO 4
    time used: 0.7931160926818848
    time used: 5.930324077606201
    time used: 23.60724925994873
       size     error       eoc  iterations
    0   318  0.001060       NaN          94
    1   854  0.000599  1.647357         390
    2  2065  0.000273  2.262345         895



.. image:: mcf-algorithm_files/mcf-algorithm_5_1.png



.. image:: mcf-algorithm_files/mcf-algorithm_5_2.png

