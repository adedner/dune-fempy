#include <dune/fem/misc/boundaryidprovider.hh>

namespace ModelTmp
{
  using namespace ::std;
  template <class GridPart#MODELTEMPLATE>
  struct Model
  {
    typedef GridPart GridPartType;
    typedef double RangeFieldType;
    static const int dimRange = DIMRANGE;
    static const int dimDomain = GridPartType::dimensionworld;
    static const int dimLocal  = GridPartType::dimension;
    typedef typename GridPart::template Codim<0>::EntityType EntityType;
    typedef typename GridPart::IntersectionType IntersectionType;
    typedef Dune::Fem::FunctionSpace< double, RangeFieldType, dimDomain, dimRange > FunctionSpaceType;
    typedef typename FunctionSpaceType::DomainType DomainType;
    typedef typename FunctionSpaceType::RangeType RangeType;
    typedef typename FunctionSpaceType::JacobianRangeType JacobianRangeType;
    typedef typename FunctionSpaceType::HessianRangeType HessianRangeType;

    std::string name() const
    {
      return "ModelTmp";
    }

    template <class Point>
    void source ( const Point &point,
             const RangeType &value,
             const JacobianRangeType &gradient,
             RangeType &flux ) const
    {
      #SOURCE
    }
    template <class Point>
    void linSource ( const RangeType& uBar,
                const JacobianRangeType &gradientBar,
                const Point &point,
                const RangeType &value,
                const JacobianRangeType &gradient,
                RangeType &flux ) const
    {
      #LINSOURCE
    }
    template <class Point>
    void diffusiveFlux ( const Point &point,
                    const RangeType &value,
                    const JacobianRangeType &gradient,
                    JacobianRangeType &flux ) const
    {
      #DIFFUSIVEFLUX
    }
    template <class Point>
    void linDiffusiveFlux ( const RangeType& uBar,
                       const JacobianRangeType& gradientBar,
                       const Point &point,
                       const RangeType &value,
                       const JacobianRangeType &gradient,
                       JacobianRangeType &flux ) const
    {
      #LINDIFFUSIVEFLUX
    }
    template <class Point>
    void fluxDivergence( const Point &point,
                         const RangeType &value,
                         const JacobianRangeType &jacobian,
                         const HessianRangeType &hessian,
                         RangeType &result) const
    {
      #RESIDUAL
    }
    template <class Point>
    void alpha(const Point &point,
          const RangeType &value,
          RangeType &val) const
    {
      #ALPHA
    }
    template <class Point>
    void linAlpha(const RangeType &uBar,
             const Point &point,
             const RangeType &value,
             RangeType &val) const
    {
      #LINALPHA
    }
    bool hasDirichletBoundary () const
    {
      #HASDIRICHLET
    }
    bool hasNeumanBoundary () const
    {
      #HASNEUMAN
    }
    bool isDirichletIntersection( const IntersectionType& inter, Dune::FieldVector<bool,dimRange> &dirichletComponent ) const
    {
      int boundaryId = Dune::Fem::BoundaryIdProvider<typename GridPart::GridType>::boundaryId(inter);
      switch (boundaryId)
      {
        #ISDIRICHLETINTERSECTION
        default: return false;
      }
    }
    template <class Point>
    void dirichlet(const intersectionType &inter,
               const Point &point,
               RangeType &val) const
    {
      #DIRICHLETDATA
    } 
    void f(const DomainType& x, RangeType& phi) const
    {
      #FORCING
    }
    void n(const DomainType& x, RangeType& value) const
    {
      #NEUMANDATA
    }
    void jacobianExact(const DomainType& x, JacobianRangeType& value) const
    {
      // used for computing H^1 error when solution is provided
      #JACOBIANEXACT
    }
    bool init(const EntityType &entity) const
    {
      #INIT
      entity_ = &entity;
      return true;
    }
    #SETCOEFFICIENT
    mutable const EntityType *entity_;
  };
}
