Calling the method \pyth{scheme.solve} will require large sparse linear
system to be solved. By default a
\emph{Generalized minimal residual} method is used which is part of the
\dune[fem] module. Other Krylov solvers are also available and can be
chosen by using the optional parameter \pyth{solver} when constructing the
scheme. Possible values are at the time of writing
\pyth{bicgstab,cg} or \pyth{gmres}.
Note that these solvers do not include preconditioners, so while they do
not rely on additional \dune{} modules or external packages they are not
very efficient for more complex settings. A further option available in
\dune[fem] is to use the \emph{Umfpack} direct solver which is part of the
suite sparse package \cite{suitesparse}. To use this solver the
\pyth{solver} parameter needs to be set to a tuple
\pyth{(\"suitesparse\",\"umfpack\")}. For the second element in the tuple
the following additional options are also available
\pyth{\"ldl\",\"spqr_symmetric\",\"spqr_nonsymmetric\"}.

Further linear algebra packages can also be used through \dune[fempy]. The
two most important ones are
PetSc \cite{petsc} and \dune[istl] \cite{duneistl}. To switch to one of
these packages requires passing either \pyth{\"petsc\"} or
\pyth{\"istl\"} as value of the \pyth{storage} parameter when constructing
the space. Discrete functions and schemes based on spaces with a changed
\pyth{storage} will use the corresponding data structures and solvers.
In both the above cases Krylov solvers will be used and can be chosen
through the \pyth{solver} parameter. For the \dune[istl] solvers
typical choices are \pyth{\"cg\",\"bicgstab\",\"gmres\",\"minres\"}.
The same values are available for the PetSc backend and in addition
\pyth{solver=\"bicg\"} can be used.

As pointed a disadvantage of the \dune[fem] internal solvers is lack of
preconditioning. Both \dune[istl] and PetSc provide a number of very
efficient preconditioners ranging from incomplete LU factorization to
algebraic multigrid solvers. The preconditioner is chosen using the
\pyth{parameters} argument to the scheme construction.
% NEED DETAILS
The \pyth{parameters} argument can be used to further customize the solver
% NEED DETAILS
