ufl2model:
-1) No generate anymore that only produces a usefull header file for use in
    C++ dune-fem context. I.e. good name no python?
-2) tmp Hilfsvariablen ausschalten?
-3) uflSpace = dune.ufl.Space(surface.dimGrid, surface.dimWorld, surface.dimWorld)
    not a nice syntax, how about 
    Space( (dimGrid,dimWorld), dimRange) bzw.
    Space( dimGrid, dimRange) which translates to (dimGrid,dimGrid)
-4) elliptic.importModel(grid, a == 0).get()


1)  model.generate( a==b ) model.generate( a_ex-a_im==b )
2)  model forcing? Always put forcing in source of DiffusionModel?
    Now all forcings are global functions (f,n). Are they needed or
    integrated into source,alpha?
    Correct way to handle non affine operators - always relly on Newton?
    Will this lead to unnecessary evaluations for linear problems?
3)  dirichlet boundaries and ids -> local and model.g(...)
4)  Throw exception, when ufl expr not known to parser
5)  flux name for return in source function - call all return values the same?
6)  remove all generated model .so from generated files on exit - perhaps say 
    if name has already been used and allow for autogenerated file names
7)  Add methods to set constatns (like coefficient functions) in
    the models, i.e., for time or deltat etc.
    Better perhaps:
    >>> dt = ufl2model.constant("dt")  
    ....
    >>> model = ufl2model.make...
    ....
    >>> model.setConstants(dict) 
    On the model we have add method 
       void setConstants(const std::map<std:string,double> &dict) 
    which iterates over the dictionary and then has something like
       if (item.first == "dt")
         dt_ = item.second;
    Or we make use of the Parameter reader interface for this, i.e.
       dt_ = dict.getValue<double>("dt");
8) Add option to avoid virtualization in coefficient function, e.g.,
    >>> un = ufl2model.coefficient("un",solution)
    which would extract the C++ type of solution and use that instead of the 
    VirtualizedGF in the Model template argument. Of course then
    >>> model.setun(oldSolution)
    would only be valid if solution._type == oldSolution._type

------------------------------------------------------------------------------------

Other stuff:
2)  extract dimworld,dimgrid from dgf file
3)  scheme.estimate -> FVFunction with estimates
4)  hierarchicalGrid needed?
5)  dune.fem new memory for dof vectors initialize with zero
7)  functional <-> function
8)  mpi4py in dune.fem.__init__? Doesn't work... Perhaps needs to be
    included in comoon.cc directly
9)  parameters e.g. istl preconditioner
10) subsampling vtk (add subsampling=sample to grid.writVTK)
11) shouldn't it be leafGrid("ALUGridSimplex,dgf,...) instead of other
    way. In all other cases the first string is the database entry
12) make hgrid.globalRefine(factor=0.3) always reduce h by 0.5, i.e., use refineStepsForHalf?
13) add option to generate to force recompilation of shared library -
    compile separate 
14) change name of refinement for ALU - it is not about conforming/non
    conforming but about bisection and ...
15) extension="yes": not needed because generateScheme<BurgersScheme>
16) have the model return the exact solution as a grid function so that one can write
    fem.h1norm(solution, m.exact() )
17) Add a way to distiguish between local and global coordinates, i.e.,
    add a "LocalFieldVectorClass" derived from FieldVector but not adding
    that base in the pybind11 export statement. Then export all method
    taking/returning local coordinate using this new type. On C++ side
    everything works as before due to the base class but on python side the
    cast is not available.
18) move generate* to details removing def of __init__. Add a register* to
    the FemPy space that calls details::register and adds the default
    constructor. Overloading of this register can be used for specific classes with a
    different constructor 

--------------------------------------------------------------------------------------

Bugs:
1)  Problem with load balancing
2)  Problem with model.set*(gf) not keeping gf alive long enough
3)  GMSH reader not working with YaspGrid due to non interface gridfactory method used
5)  database can not contain parameters with numbers (at least space0 failed)
6)  if a scheme has a fixed storage one has to make sure that the correct storage is
    really used and the correct discrete function types are registered. An easier approach
    to registration should be made available in the C++ bindings as well
    Solution: Have a const parameter in the schem
7) grid._includes does not contain gridpart header

------------------------------------------------------------------------------------

heat and copy/initialization?

- writeVTK: number->sequence or padding
    >>> a = "hallo" + '%04d' % n
    >>> aa = '{0:03d}'.format(4)

- construction of grids: geometry type for dictonary
- element.geometry -> element

pointData=[uh,vh,wh] oder
pointData={scalar:[uh,vh,wh],vector:[velocity]}
