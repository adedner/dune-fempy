ufl2model:
1)  model.generate( a==b ) model.generate( a_ex-a_im==b )
2)  model forcing? Always put forcing in source of DiffusionModel?
    Now all forcings are global functions (f,n). Are they needed or
    integrated into source,alpha?
    Correct way to handle non affine operators - always relly on Newton?
    Will this lead to unnecessary evaluations for linear problems?
3)  dirichlet boundaries and ids -> local and model.g(...)
4)  Throw exception, when ufl expr not known to parser
5)  flux name for return in source function - call all return values the same?
6)  remove all generated model .so from generated files on exit - perhaps say 
    if name has already been used and allow for autogenerated file names
7)  Add methods to set constatns (like coefficient functions) in
    the models, i.e., for time or deltat etc.
    Better perhaps:
    >>> dt = ufl2model.constant("dt")  
    ....
    >>> model = ufl2model.make...
    ....
    >>> model.setConstants(dict) 
    On the model we have add method 
       void setConstants(const std::map<std:string,double> &dict) 
    which iterates over the dictionary and then has something like
       if (item.first == "dt")
         dt_ = item.second;
    Or we make use of the Parameter reader interface for this, i.e.
       dt_ = dict.getValue<double>("dt");
8) Add option to avoid virtualization in coefficient function, e.g.,
    >>> un = ufl2model.coefficient("un",solution)
    which would extract the C++ type of solution and use that instead of the 
    VirtualizedGF in the Model template argument. Of course then
    >>> model.setun(oldSolution)
    would only be valid if solution._type == oldSolution._type

------------------------------------------------------------------------------------

Other stuff:
2)  extract dimworld,dimgrid from dgf file
3)  scheme.estimate -> FVFunction with estimates
4)  hierarchicalGrid needed?
5)  dune.fem new memory for dof vectors initialize with zero
7)  functional <-> function
8)  mpi4py in dune.fem.__init__? Doesn't work... Perhaps needs to be
    included in comoon.cc directly
9)  parameters e.g. istl preconditioner
10) subsampling vtk (add subsampling=sample to grid.writVTK)
11) shouldn't it be leafGrid("ALUGridSimplex,dgf,...) instead of other
    way. In all other cases the first string is the database entry
12) make hgrid.globalRefine() always reduce h by 0.5, i.e., use refineStepsForHalf?
13) add option to generate to force recompilation of shared library
14) change name of refinement for ALU - it is not about conforming/non
    conforming but about bisection and ...

--------------------------------------------------------------------------------------

Bugs:
1)  Problem with load balancing
2)  Problem with model.set*(gf) not keeping gf alive long enough
3)  GMSH reader not working with YaspGrid due to non interface gridfactory method used
4)  database can not contain parameters with numbers (at least space0 failed)
5)  if a scheme has a fixed storage one has to make sure that the correct storage is
    really used and the correct discrete function types are registered. An easier approach
    to registration should be made available in the C++ bindings as well

------------------------------------------------------------------------------------
